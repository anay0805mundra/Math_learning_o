<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Math Learning-o</title>
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@v2.1.5/dist/tesseract.min.js"></script>
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/12.4.1/math.min.js"></script>
<style>
  body { font-family: Arial, sans-serif; margin: 20px; background:#f9f9f9; }
  h1 { color: #2c3e50; }
  #steps { border: 1px solid #ccc; background: white; padding: 15px; height: 200px; overflow-y: auto; margin-top: 15px; }
  button, select, input, textarea { font-size: 1rem; margin: 5px 0; padding: 7px; }
  #graph { margin-top: 20px; width: 100%; max-width: 600px; height: 400px; }
  .error { color: red; }
  .bold { font-weight: bold; }
</style>
</head>
<body>

<h1>Math Learning-o</h1>

<label for="topic">Select Topic:</label><br/>
<select id="topic" style="width: 300px;">
  <option value="">-- Choose Topic --</option>
  <option value="SimpleIntrest">Simple Intrest </option>
  <option value="polynomials">Polynomials</option>
  <option value="inequalities">Inequalities</option>
  <option value="algebraicExpressions">Algebraic Expressions</option>
  <option value="probability">Probability</option>
  <option value="fractions">Fractions</option>
  <option value="decimals">Decimals</option>
  <option value="exponents">Exponents</option>
  <option value="rationalNumbers">Rational Numbers</option>
  <option value="squaresCubesRoots">Squares, Cubes & Roots</option>
  <option value="integers">Integers</option>
  <option value="percentage">Percentage</option>
  <option value="perimeter">Perimeter</option>
  <option value="area">Area</option>
  <option value="volumeSurface">Volume & Surface Area</option>
  <option value="geometry">Geometry </option>
  <option value="CompoundIntrest">Compound Intrest </option>
  <option value="MCQTEST">MCQ Test </option>
</select><br/>

<label for="question">Enter your math question:</label><br/>
<textarea id="question" rows="4" cols="60" placeholder="Type your question or math expression here..."></textarea><br/>

<label for="imageInput">Or upload a math problem image:</label><br/>
<input type="file" id="imageInput" accept="image/*" /><br/>

<button onclick="startVoiceInput()">ğŸ¤ Voice Input</button>
<button onclick="solve()">Solve</button>
<button onclick="clearOutput()">Clear</button>

<div id="steps"></div>
<div id="graph"></div>

<script>
function addStep(text, isFinal=false) {
  const steps = document.getElementById('steps');
  const p = document.createElement('p');
  if(isFinal) p.classList.add('bold');
  p.textContent = text;
  steps.appendChild(p);
  steps.scrollTop = steps.scrollHeight;
}
function clearOutput() {
  document.getElementById('steps').innerHTML = '';
  document.getElementById('graph').innerHTML = '';
}

document.getElementById('imageInput').addEventListener('change', (e) => {
  clearOutput();
  const file = e.target.files[0];
  if(!file) return;
  addStep('ğŸ–¼ï¸ Processing imageâ€¦');
  Tesseract.recognize(file, 'eng', {
    logger: m => {
      if(m.status === 'recognizing text') addStep('â€¦ OCR progress: ' + Math.round(m.progress * 100) + '%');
    }
  }).then(({ data: { text }}) => {
    const cleanText = text.trim().replace(/\n/g, ' ');
    document.getElementById('question').value = cleanText;
    addStep('ğŸ“ OCR extracted text: ' + cleanText, true);
  }).catch(err => addStep('OCR error: ' + err.message, true));
});

function startVoiceInput() {
  if (!('webkitSpeechRecognition' in window)) {
    alert('Speech Recognition not supported in this browser.');
    return;
  }
  clearOutput();
  addStep('ğŸ™ï¸ Listening... Speak now.');
  const recognition = new webkitSpeechRecognition();
  recognition.lang = 'en-US';
  recognition.interimResults = false;
  recognition.maxAlternatives = 1;
  recognition.start();
  recognition.onresult = (event) => {
    const spokenText = event.results[0][0].transcript;
    document.getElementById('question').value = spokenText;
    addStep('ğŸ™ï¸ Recognized text: ' + spokenText, true);
  };
  recognition.onerror = (event) => {
    addStep('Speech recognition error: ' + event.error, true);
  };
}

function solve() {
  clearOutput();
  const topic = document.getElementById('topic').value;
  const question = document.getElementById('question').value.trim();
  if (!topic) return addStep('âš ï¸ Please select a topic.', true);
  if (!question) return addStep('âš ï¸ Please enter or upload a question.', true);
  try {
    switch(topic) {
      case 'polynomials': return solvePolynomial(question);
      case 'inequalities': return solveInequality(question);
      case 'algebraicExpressions': return solveAlgebraic(question);
      case 'probability': return solveProbability(question);
      case 'fractions': return solveBasic("Fractions", question);
      case 'decimals': return solveBasic("Decimals", question);
      case 'exponents': return solveBasic("Exponents", question);
      case 'rationalNumbers': return solveBasic("Rational Numbers", question);
      case 'squaresCubesRoots': return solveBasic("Squares, Cubes & Roots", question);
      case 'integers': return solveBasic("Integers", question);
      case 'percentage': return solveBasic("Percentage", question);
      case 'perimeter': return solveBasic("Perimeter", question);
      case 'area': return solveBasic("Area", question);
      case 'volumeSurface': return solveBasic("Volume & Surface Area", question);
      case 'geometry': return solveGeometry(question);
      case 'simpleintrest': return solveSimpleIntrest(question);
      case 'geometry': return solveCompoundIntrest(question);
      case 'MCQTEST': return solveMCQTEST(question);
      default:
        return addStep('âŒ Unknown topic.', true);
    }
  } catch (e) {
    addStep('âŒ Error: ' + e.message, true);
  }
}

function solveBasic(title, input) {
  addStep(`ğŸ” Solving ${title}...`);
  try {
    const result = math.evaluate(input);
    addStep(`âœ… Answer: ${result}`, true);
  } catch (e) {
    addStep('âŒ Could not solve. Try rewriting the expression.', true);
  }
}

function solveAlgebra(q) {
  addStep(`ğŸ“˜ Solving Algebraic Expression: ${q}`);
  const expr = q.toLowerCase();

  // Special Identity Detection
  if (/\(.*\+.*\)\^2/.test(expr)) {
    addStep('ğŸ§  Identity Detected: (a + b)^2 = a^2 + 2ab + b^2');
    return;
  }
  if (/\(.*-.*\)\^2/.test(expr)) {
    addStep('ğŸ§  Identity Detected: (a - b)^2 = a^2 - 2ab + b^2');
    return;
  }
  if (/\(.*\+.*\)\(.*-.*\)/.test(expr)) {
    addStep('ğŸ§  Identity Detected: (a + b)(a - b) = a^2 - b^2');
    return;
  }

  // Try direct simplification
  if (/[\d\w\s+\-*/^=()]+/.test(expr)) {
    try {
      const simplified = math.simplify(expr).toString();
      return addStep(`âœ… Simplified Expression: ${simplified}`);
    } catch {
      // Let it fall through
    }
  }
// Age based problems
  const regex = /a man is (\d+) times (?:as )?old as his son.*?in (\d+) years.*?he will be (\d+) times (?:as )?old as his son/i;
  const match = input.match(regex);

  if (match) {
    const factorNow = parseInt(match[1]);
    const yearsLater = parseInt(match[2]);
    const factorFuture = parseInt(match[3]);

    addStep(`Let son's age = x`);
    addStep(`Then man's age = ${factorNow}x`);

    addStep(`In ${yearsLater} years:`);
    addStep(`${factorNow}x + ${yearsLater} = ${factorFuture}(x + ${yearsLater})`);

    const equationLeft = `${factorNow}x + ${yearsLater}`;
    const equationRight = `${factorFuture}x + ${factorFuture * yearsLater}`;

    addStep(`Equation: ${equationLeft} = ${equationRight}`);

    const xNumerator = (factorFuture * yearsLater) - yearsLater;
    const xDenominator = factorNow - factorFuture;
    const x = xNumerator / xDenominator;

    const manAge = factorNow * x;

    addStep(`x = (${factorFuture} Ã— ${yearsLater} - ${yearsLater}) / (${factorNow} - ${factorFuture})`);
    addStep(`x = ${x}`);
    addStep(`âœ… Son's age = ${x} years`);
    addStep(`âœ… Man's age = ${manAge} years`, true);
  } else {
    addStep("âŒ This age problem format isn't recognized yet. Try: 'A man is 13 times as old as his son. In 10 years...'", true);
  }
}

  }

  // Monomial, binomial or polynomial arithmetic
  if (expr.includes("+") || expr.includes("-") || expr.includes("*") || expr.includes("/")) {
    try {
      const simplified = math.simplify(expr);
      return addStep(`âœ… Simplified Algebraic Expression: ${simplified}`);
    } catch (e) {
      return addStep('âŒ Invalid algebraic expression.');
    }
  }

  addStep('ğŸ“š Try expressions like "2x + 3x - 4", or "aÂ² + 2ab + bÂ²", or "age problems like A is 3 years older than B".');
}

  
function solveSquares(q) {
  addStep(`ğŸ§  Solving Square, Cube & Root: ${q}`);
  const numMatch = q.match(/(-?\d+(\.\d+)?)/);
  if (!numMatch) return addStep('âŒ No number found.');

  const num = parseFloat(numMatch[1]);

  if (/square root/i.test(q)) {
    const root = Math.sqrt(num).toFixed(4);
    return addStep(`âˆš${num} = ${root}`);
  }

  if (/cube root/i.test(q)) {
    const root = Math.cbrt(num).toFixed(4);
    return addStep(`âˆ›${num} = ${root}`);
  }

  if (/square of/i.test(q)) {
    const square = (num ** 2).toFixed(2);
    return addStep(`${num}Â² = ${square}`);
  }

  if (/cube of/i.test(q)) {
    const cube = (num ** 3).toFixed(2);
    return addStep(`${num}Â³ = ${cube}`);
  }

  if (/perfect square/i.test(q)) {
    const sqrt = Math.sqrt(num);
    if (Number.isInteger(sqrt)) {
      return addStep(`âœ… ${num} is a perfect square. âˆš${num} = ${sqrt}`);
    } else {
      const next = Math.ceil(sqrt) ** 2;
      const diff = next - num;
      return addStep(`âŒ Not a perfect square. Add ${diff} to make it ${next}`);
    }
  }

  if (/perfect cube/i.test(q)) {
    const cbrt = Math.cbrt(num);
    if (Number.isInteger(cbrt)) {
      return addStep(`âœ… ${num} is a perfect cube. âˆ›${num} = ${cbrt}`);
    } else {
      const next = Math.round(cbrt + 1) ** 3;
      const diff = next - num;
      return addStep(`âŒ Not a perfect cube. Add ${diff} to make it ${next}`);
    }
  }

  if (/smallest \d+-digit perfect square/.test(q)) {
    const digits = parseInt(q.match(/smallest (\d+)-digit/)[1]);
    const start = 10 ** (digits - 1);
    const root = Math.ceil(Math.sqrt(start));
    const square = root ** 2;
    return addStep(`ğŸŸ© Smallest ${digits}-digit perfect square is ${square}`);
  }

  if (/add|subtract|multiply|divide/i.test(q) && /to make.*perfect (square|cube)/i.test(q)) {
    const type = q.includes("square") ? "square" : "cube";
    const base = type === "square" ? Math.ceil(Math.sqrt(num)) : Math.ceil(Math.cbrt(num));
    const target = type === "square" ? base ** 2 : base ** 3;
    const add = target - num;
    const subtract = num - (type === "square" ? (base - 1) ** 2 : (base - 1) ** 3);
    addStep(`${num} + ${add} = ${target} (make perfect ${type})`);
    addStep(`${num} - ${subtract} = ${(type === "square" ? (base - 1) ** 2 : (base - 1) ** 3)} (make perfect ${type})`);
    return;
  }

  addStep('ğŸ“š Use keywords like "square of", "cube root of", "perfect square", etc.');
}
function solveProfitLoss(q) {
  addStep(`ğŸ’° Solving Profit & Loss Question: ${q}`);
  q = q.toLowerCase();

  const cpMatch = q.match(/cost price.*?(\d+(\.\d+)?)/);
  const spMatch = q.match(/selling price.*?(\d+(\.\d+)?)/);

  if (cpMatch && spMatch) {
    const cp = parseFloat(cpMatch[1]);
    const sp = parseFloat(spMatch[1]);
    if (sp > cp) {
      const profit = sp - cp;
      const percent = ((profit / cp) * 100).toFixed(2);
      return addStep(`âœ… Profit = Rs.${profit}, Profit% = ${percent}%`);
    } else if (cp > sp) {
      const loss = cp - sp;
      const percent = ((loss / cp) * 100).toFixed(2);
      return addStep(`âœ… Loss = Rs.${loss}, Loss% = ${percent}%`);
    } else {
      return addStep('âš–ï¸ No Profit, No Loss.');
    }
  }

  const percentMatch = q.match(/profit.*?(\d+)%|loss.*?(\d+)%/);
  const type = q.includes("profit") ? "profit" : q.includes("loss") ? "loss" : null;
  const cpOnly = q.match(/cost price.*?(\d+(\.\d+)?)/);

  if (percentMatch && cpOnly) {
    const percent = parseFloat(percentMatch[1] || percentMatch[2]);
    const cp = parseFloat(cpOnly[1]);
    const amount = (percent / 100) * cp;
    const sp = type === "profit" ? cp + amount : cp - amount;
    return addStep(`âœ… ${type === "profit" ? 'SP = CP + Profit' : 'SP = CP - Loss'} = Rs.${sp}`);
  }

  addStep("ğŸ“š Try phrases like 'Cost price is 80, selling price is 100' or 'Profit is 20% on Rs. 500'");
}
let latestChartData = null; // Global chart data holder

function solveDataHandling(q) {
  addStep(`ğŸ“Š Interpreting Data Handling Question: ${q}`);

  // Supplementary question handling
  if (latestChartData && /how many|which|total|most|least/i.test(q)) {
    return handleChartQuestions(q);
  }

  // Detect chart type
  if (/bar\s*graph/i.test(q)) return renderBarGraph(q);
  if (/line\s*graph/i.test(q)) return renderLineGraph(q);
  if (/pie\s*chart/i.test(q)) return renderPieChart(q);
  if (/tally\s*marks?/i.test(q)) return renderTally(q);
  if (/pictograph/i.test(q)) return renderPictograph(q);

  addStep('ğŸ“Œ Please specify a chart type (e.g., "Draw a bar graph of Apples:10, Oranges:20")');
}

// Parses data like "Apples:10, Oranges:20"
function parseData(q) {
  const match = q.match(/([a-zA-Z ]+):\s*(\d+)/g);
  if (!match) return null;
  const parsed = match.map(pair => {
    const [label, value] = pair.split(':');
    return { label: label.trim().toLowerCase(), value: parseInt(value.trim()) };
  });
  latestChartData = parsed;
  return parsed;
}

// Supplementary Q&A about charts
function handleChartQuestions(q) {
  q = q.toLowerCase();

  if (q.includes('how many')) {
    const labelMatch = latestChartData.find(d => q.includes(d.label));
    if (labelMatch) return addStep(`âœ… ${labelMatch.label} = ${labelMatch.value}`);
    return addStep('âŒ Could not find that item in the chart.');
  }

  if (q.includes('total')) {
    const total = latestChartData.reduce((sum, d) => sum + d.value, 0);
    return addStep(`ğŸ§® Total = ${total}`);
  }

  if (q.includes('most') || q.includes('highest') || q.includes('maximum')) {
    const max = latestChartData.reduce((a, b) => a.value > b.value ? a : b);
    return addStep(`ğŸ“ˆ Highest = ${max.label} (${max.value})`);
  }

  if (q.includes('least') || q.includes('lowest') || q.includes('minimum')) {
    const min = latestChartData.reduce((a, b) => a.value < b.value ? a : b);
    return addStep(`ğŸ“‰ Lowest = ${min.label} (${min.value})`);
  }

  return addStep('â“ Could not interpret the supplementary question.');
}

// Visual Renderers (unchanged â€“ only updated for shared data usage)
function renderBarGraph(q) {
  const data = parseData(q);
  if (!data) return addStep('âŒ Could not parse bar graph data.');
  addStep('ğŸ“Š Bar Graph:');
  data.forEach(({ label, value }) => {
    addStep(`${label}: ` + 'â–®'.repeat(Math.round(value / 2)));
  });
}

function renderLineGraph(q) {
  const data = parseData(q);
  if (!data) return addStep('âŒ Could not parse line graph data.');
  addStep('ğŸ“ˆ Line Graph Trend:');
  let prev = 0;
  data.forEach(({ label, value }) => {
    const trend = value > prev ? 'â†—ï¸' : value < prev ? 'â†˜ï¸' : 'â¡ï¸';
    addStep(`${label}: ${value} ${trend}`);
    prev = value;
  });
}

function renderPieChart(q) {
  const data = parseData(q);
  if (!data) return addStep('âŒ Could not parse pie chart data.');
  const total = data.reduce((sum, d) => sum + d.value, 0);
  addStep('ğŸ¥§ Pie Chart Angles:');
  data.forEach(({ label, value }) => {
    const angle = ((value / total) * 360).toFixed(1);
    addStep(`${label}: ${angle}Â°`);
  });
}

function renderTally(q) {
  const data = parseData(q);
  if (!data) return addStep('âŒ Could not parse tally data.');
  addStep('ğŸ“‹ Tally Representation:');
  data.forEach(({ label, value }) => {
    const fives = Math.floor(value / 5);
    const rem = value % 5;
    const tally = 'âŸŸ'.repeat(fives) + '|'.repeat(rem);
    addStep(`${label}: ${tally}`);
  });
}

function renderPictograph(q) {
  const data = parseData(q);
  if (!data) return addStep('âŒ Could not parse pictograph data.');
  addStep('ğŸ–¼ï¸ Pictograph (1 ğŸ = 5 units):');
  data.forEach(({ label, value }) => {
    const symbols = 'ğŸ'.repeat(Math.round(value / 5));
    addStep(`${label}: ${symbols}`);
  });
}
// Topic Logic: Exponents
function solveExponents(q) {
  addStep(`âš¡ Solving Exponents: ${q}`);

  // Handle standard/exponential form conversion
  const stdFormMatch = q.match(/(standard|exponential).*?(number\s*is\s*)?(\d+(?:\.\d+)?)/i);
  if (stdFormMatch) {
    const num = parseFloat(stdFormMatch[3]);
    const sci = num.toExponential();
    return addStep(`ğŸ“ ${num} in standard form = ${sci}`);
  }

  // Handle arithmetic operations with exponents (e.g., 2^3 * 2^4)
  const expoMatch = q.match(/(\d+)\s*\^\s*(\d+)\s*([+\-*/])\s*(\d+)\s*\^\s*(\d+)/);
  if (expoMatch) {
    const [_, a1, p1, op, a2, p2] = expoMatch;
    if (a1 === a2) {
      let result;
      switch (op) {
        case '*': result = `${a1}^${+p1 + +p2}`; break;
        case '/': result = `${a1}^${+p1 - +p2}`; break;
        default: result = 'Cannot apply laws of exponents for + or - with same base';
      }
      return addStep(`ğŸ§® Using laws of exponents â†’ ${a1}^${p1} ${op} ${a2}^${p2} = ${result}`);
    }
  }

  // Calculate a single exponential (e.g., 5^3)
  const single = q.match(/(\d+(?:\.\d+)?)\s*\^\s*(-?\d+)/);
  if (single) {
    const base = parseFloat(single[1]);
    const power = parseInt(single[2]);
    const result = Math.pow(base, power);
    return addStep(`âœ… ${base}^${power} = ${result}`);
  }

  // Convert large/small numbers to exponential
  const largeSmall = q.match(/convert\s+(\d+\.?\d*)\s+to\s+exponential\s+form/i);
  if (largeSmall) {
    const number = parseFloat(largeSmall[1]);
    return addStep(`ğŸ“ ${number} in exponential form: ${number.toExponential()}`);
  }

  addStep('ğŸ“š Try: "Convert 6872 to exponential", "2^3 * 2^5", or "Standard form of 0.000034".');
}
// Topic Logic: Percentage
function solvePercentage(q) {
  addStep(`ğŸ“Š Solving Percentage Problem: ${q}`);

  // Convert % to decimal or fraction
  if (/(\d+(\.\d+)?)\s*%/.test(q)) {
    const num = parseFloat(q.match(/(\d+(\.\d+)?)\s*%/)[1]);
    addStep(`ğŸ” Decimal = ${num} / 100 = ${num / 100}`);
    addStep(`ğŸ” Fraction = ${num}/100`);
    return;
  }

  // Convert to percentage
  const fracMatch = q.match(/(\d+)\/(\d+)/);
  if (fracMatch) {
    const perc = (parseInt(fracMatch[1]) / parseInt(fracMatch[2])) * 100;
    addStep(`âœ… Percentage = (${fracMatch[1]} Ã· ${fracMatch[2]}) Ã— 100 = ${perc.toFixed(2)}%`);
    return;
  }

  // Ratio to percentage
  const ratioMatch = q.match(/(\d+)\s*:\s*(\d+)/);
  if (ratioMatch) {
    const perc = (parseInt(ratioMatch[1]) / parseInt(ratioMatch[2])) * 100;
    addStep(`âœ… Percentage = (${ratioMatch[1]} Ã· ${ratioMatch[2]}) Ã— 100 = ${perc.toFixed(2)}%`);
    return;
  }

  // Word problem detection
  const wp = q.match(/(\d+)[\s\w]*\b(?:of|on)\b[\s\w]*(\d+)/i);
  if (wp) {
    const perc = parseFloat(wp[1]);
    const base = parseFloat(wp[2]);
    const result = (perc / 100) * base;
    addStep(`âœ… ${perc}% of ${base} = (${perc}/100) Ã— ${base} = ${result}`);
    return;
  }

  // Reverse: "45 is what percent of 180?"
  const reverse = q.match(/(\d+)[\s\w]*percent[\s\w]*(\d+)/i) || q.match(/(\d+)[\s\w]*of[\s\w]*(\d+)/i);
  if (reverse) {
    const part = parseFloat(reverse[1]);
    const whole = parseFloat(reverse[2]);
    const perc = (part / whole) * 100;
    addStep(`ğŸ” ${part} is ${(perc).toFixed(2)}% of ${whole}`);
    return;
  }

  addStep(`ğŸ“š Try using inputs like: "20% of 50", "2/5 as %", "8:10 as %", or "45 is what percent of 180?"`);
}
// Topic Logic: Factorisation
function solveFactorisation(q) {
  addStep(`ğŸ§® Solving Factorisation: ${q}`);

  try {
    const simplified = math.simplify(q);
    const factored = math.factor(q);

    if (simplified.toString() !== factored.toString()) {
      addStep(`ğŸ§¾ Simplified: ${simplified}`);
      addStep(`âœ… Factored: ${factored}`);
    } else {
      addStep(`ğŸ“Œ No further factorisation possible. Simplified: ${simplified}`);
    }
  } catch (e) {
    addStep(`âŒ Could not factor the expression. Try simpler form or check syntax.`);
    return;
  }

  // Handle common patterns manually if needed
  if (/^(\d+)(x\^2)\+(\d+)(x)\+(\d+)$/.test(q.replace(/\s+/g, ''))) {
    addStep(`ğŸ“š Looks like a quadratic trinomial. Consider middle-term splitting.`);
  }

  if (/x\^2\s*-\s*\d+/.test(q)) {
    const num = parseInt(q.match(/x\^2\s*-\s*(\d+)/)[1]);
    const root = Math.sqrt(num);
    if (Number.isInteger(root)) {
      addStep(`âœ… This is a difference of squares: (x + ${root})(x - ${root})`);
    }
  }

  if (/\(.+\)\(.+\)/.test(q)) {
    addStep(`ğŸ” This appears already factored.`);
  }
}
// Topic Logic: Polynomials
function solvePolynomials(q) {
  addStep(`ğŸ”¢ Solving Polynomial: ${q}`);

  const terms = q.match(/[+-]?\s*\d*[a-z]?\^?\d*/gi)?.filter(t => t.trim() !== '');
  if (!terms || terms.length === 0) {
    return addStep('âŒ Could not detect polynomial terms. Try rephrasing.');
  }

  const simplified = terms.map(t => t.replace(/\s+/g, '')).join(' + ').replace(/\+\s*\-/g, '- ');
  addStep(`ğŸ” Parsed Terms: ${simplified}`);

  // Degree calculation
  const degrees = terms.map(t => {
    const match = t.match(/\^(\d+)/);
    return match ? parseInt(match[1]) : (/[a-z]/i.test(t) ? 1 : 0);
  });

  const maxDegree = Math.max(...degrees);
  addStep(`ğŸ“ Degree of the polynomial: ${maxDegree}`);

  if (terms.length === 1) {
    addStep(`ğŸ“˜ This is a monomial.`);
  } else if (terms.length === 2) {
    addStep(`ğŸ“˜ This is a binomial.`);
  } else if (terms.length === 3) {
    addStep(`ğŸ“˜ This is a trinomial.`);
  } else {
    addStep(`ğŸ“˜ This is a polynomial with ${terms.length} terms.`);
  }

  // If two polynomials given for operations
  const opMatch = q.match(/(.+)\s*(\+|\-|\*)\s*(.+)/);
  if (opMatch) {
    const [, first, operator, second] = opMatch;
    try {
      const result = math.simplify(`(${first}) ${operator} (${second})`).toString();
      addStep(`âœ… ${first} ${operator} ${second} = ${result}`);
    } catch {
      addStep('âš ï¸ Unable to simplify polynomial operation.');
    }
  } else {
    try {
      const simplified = math.simplify(q).toString();
      addStep(`ğŸ§® Simplified Polynomial: ${simplified}`);
    } catch {
      addStep('âš ï¸ Unable to simplify the polynomial.');
    }
  }
}
// Topic Logic: Polynomials
function solvePolynomials(q) {
  addStep(`ğŸ”¢ Solving Polynomial Problem: ${q}`);

  if (/add|sum|plus/i.test(q) && q.includes('x')) {
    const match = q.match(/([-+]?[\d]*x(?:\^\d+)?)/g);
    if (match && match.length >= 2) {
      const expr = match.join(' + ');
      return solveBasic("Polynomial Addition", expr);
    }
  }

  if (/subtract|minus/i.test(q) && q.includes('x')) {
    const match = q.match(/([-+]?[\d]*x(?:\^\d+)?)/g);
    if (match && match.length >= 2) {
      const expr = match[0] + ' - ' + match[1];
      return solveBasic("Polynomial Subtraction", expr);
    }
  }

  if (/multiply|product/i.test(q)) {
    const match = q.match(/([-+]?\d*x(?:\^\d+)?)/g);
    if (match && match.length >= 2) {
      const expr = match[0] + ' * ' + match[1];
      return solveBasic("Polynomial Multiplication", expr);
    }
  }

  if (/divide/i.test(q)) {
    const match = q.match(/([-+]?\d*x(?:\^\d+)?)/g);
    if (match && match.length >= 2) {
      const expr = match[0] + ' / ' + match[1];
      return solveBasic("Polynomial Division", expr);
    }
  }

  if (/like terms/i.test(q)) {
    return addStep("âœ… Like terms are those with the same variables and powers. Combine their coefficients.");
  }

  if (/degree/i.test(q)) {
    const match = q.match(/x\^(\d+)/);
    if (match) return addStep(`ğŸ“ Degree of the polynomial is ${match[1]}`);
    const linearMatch = q.match(/x(?!\^)/);
    if (linearMatch) return addStep("ğŸ“ Degree of the polynomial is 1");
  }

  addStep('ğŸ“š Try using operations like add, subtract, multiply, divide polynomials or ask about degrees.');
}
function solvePolynomials(q) {
  addStep(`ğŸ§® Solving Polynomial Expression: ${q}`);
  try {
    // Match basic polynomial patterns
    if (/[\+\-\*\/]/.test(q) && /x/.test(q)) {
      const cleaned = q.replace(/\^/g, '**');
      const simplified = math.simplify(cleaned).toString();
      addStep(`âœ… Simplified Polynomial: ${simplified}`);
      return;
    }

    // Check degree of polynomial
    const xTerms = q.match(/x\^?\d*/g);
    if (xTerms) {
      const degrees = xTerms.map(t => {
        const power = t.split('^')[1];
        return power ? parseInt(power) : 1;
      });
      const maxDegree = Math.max(...degrees);
      addStep(`ğŸ“˜ Degree of the polynomial: ${maxDegree}`);
    }

    // Factorization using algebra
    const factored = math.simplify(`factor(${q})`);
    if (factored && factored.toString() !== q) {
      addStep(`ğŸ§© Factored Form: ${factored.toString()}`);
    }

    // Evaluate at a given value
    const evalMatch = q.match(/(.+)\s+at\s+x\s*=\s*(-?\d+)/i);
    if (evalMatch) {
      const expr = evalMatch[1];
      const xVal = parseFloat(evalMatch[2]);
      const exprWithX = expr.replace(/x/g, `(${xVal})`).replace(/\^/g, '**');
      const result = math.evaluate(exprWithX);
      addStep(`ğŸ“ Value of polynomial at x = ${xVal}: ${result}`);
    }
  } catch (e) {
    addStep(`âŒ Could not solve the polynomial: ${e.message}`);
  }
}
function solveLinear(q) {
  addStep(`ğŸ“— Solving Linear Equation: ${q}`);

  // 1. One-variable equations like "2x + 3 = 11"
  if (/^[\d\w\s+\-*/=x]+$/.test(q)) {
    try {
      const expr = q.replace(/\s/g, '');
      const [left, right] = expr.split('=');
      const equation = `${left} - (${right})`;  // Move everything to LHS
      const solution = math.simplify(equation).solveFor("x");
      addStep(`âœ… x = ${solution}`, true);
      return;
    } catch (e) {
      addStep('âŒ Unable to solve algebraically. Try a valid one-variable equation.', true);
    }
  }

  // 2. Two-variable equations: "x + y = 5 and x - y = 1"
  if (/x\s*[\+\-*/]\s*y\s*=\s*\d+/i.test(q) && /and/i.test(q)) {
    const eqns = q.split(/and/i).map(e => e.trim());
    try {
      const solutions = math.solve(eqns, ['x', 'y']);
      addStep(`âœ… x = ${solutions.x}, y = ${solutions.y}`, true);
      return;
    } catch {
      addStep('âŒ Could not solve the system of equations.', true);
    }
  }

  // 3. Word Problem: "The sum of two numbers is 20 and their difference is 6"
  if (/sum.*?(\d+).*?difference.*?(\d+)/i.test(q)) {
    const sum = parseInt(q.match(/sum.*?(\d+)/i)[1]);
    const diff = parseInt(q.match(/difference.*?(\d+)/i)[1]);

    const a = (sum + diff) / 2;
    const b = sum - a;

    addStep(`Let the two numbers be x and y.`);
    addStep(`x + y = ${sum}, x - y = ${diff}`);
    addStep(`Solving gives: x = ${(sum + diff) / 2}, y = ${(sum - diff) / 2}`);
    addStep(`âœ… Numbers: ${a} and ${b}`, true);
    return;
  }

  // 4. Cost-based problem: "2 pens and 3 pencils cost â‚¹28"
  if (/(\d+)\s*pens?.*?(\d+)\s*pencils?.*?(\d+)/i.test(q)) {
    const [_, pCount, pencilCount, total] = q.match(/(\d+)\s*pens?.*?(\d+)\s*pencils?.*?(\d+)/i);
    addStep(`Let cost of pen = x, pencil = y`);
    addStep(`${pCount}x + ${pencilCount}y = ${total}`);
    addStep(`âš ï¸ One equation with two unknowns. More info needed to solve.`); 
    return;
  }

  addStep('ğŸ“š Please provide a solvable linear equation or word problem format.', true);
}
function solveDivisibility(q) {
  addStep('ğŸ” Checking Divisibility Rules for: ' + q);
  const numMatch = q.match(/\d+/g);
  if (!numMatch) return addStep('âŒ No number found in input.', true);
  const num = parseInt(numMatch[0]);

  const checks = [
    { rule: 2, valid: num % 2 === 0, explanation: 'even number (last digit 0,2,4,6,8)' },
    { rule: 3, valid: sumDigits(num) % 3 === 0, explanation: 'sum of digits divisible by 3' },
    { rule: 4, valid: num % 100 % 4 === 0, explanation: 'last 2 digits divisible by 4' },
    { rule: 5, valid: num % 10 === 0 || num % 10 === 5, explanation: 'ends in 0 or 5' },
    { rule: 6, valid: num % 2 === 0 && sumDigits(num) % 3 === 0, explanation: 'divisible by both 2 and 3' },
    { rule: 7, valid: num % 7 === 0, explanation: 'remainder is 0 when divided by 7' },
    { rule: 8, valid: num % 1000 % 8 === 0, explanation: 'last 3 digits divisible by 8' },
    { rule: 9, valid: sumDigits(num) % 9 === 0, explanation: 'sum of digits divisible by 9' },
    { rule: 10, valid: num % 10 === 0, explanation: 'ends in 0' },
    { rule: 11, valid: isDiv11(num), explanation: 'alternating sum of digits divisible by 11' },
    { rule: 13, valid: num % 13 === 0, explanation: 'remainder is 0 when divided by 13' },
    { rule: 15, valid: num % 3 === 0 && num % 5 === 0, explanation: 'divisible by both 3 and 5' },
    { rule: 17, valid: num % 17 === 0, explanation: 'remainder is 0 when divided by 17' },
    { rule: 19, valid: num % 19 === 0, explanation: 'remainder is 0 when divided by 19' }
  ];

  checks.forEach(({ rule, valid, explanation }) => {
    addStep(`â¤ ${num} is ${valid ? '' : 'not '}divisible by ${rule} (${explanation})`);
  });

  function sumDigits(n) {
    return n.toString().split('').reduce((sum, d) => sum + parseInt(d), 0);
  }

  function isDiv11(n) {
    const digits = n.toString().split('').map(Number);
    const altSum = digits.reduce((sum, digit, i) => sum + (i % 2 === 0 ? digit : -digit), 0);
    return altSum % 11 === 0;
  }
}
function solveInequalities(q) {
  addStep(`ğŸ“ Solving Inequality: ${q}`);

  // Normalize inequality operators
  q = q.replace(/â‰¤/g, "<=").replace(/â‰¥/g, ">=");

  const compoundMatch = q.match(/(.*?)(<=|<|>=|>)(.*?)(<=|<|>=|>)(.*)/);
  if (compoundMatch) {
    const left = compoundMatch[1].trim();
    const op1 = compoundMatch[2];
    const mid = compoundMatch[3].trim();
    const op2 = compoundMatch[4];
    const right = compoundMatch[5].trim();

    addStep(`ğŸ“˜ Compound inequality detected: ${left} ${op1} ${mid} ${op2} ${right}`);

    try {
      // Convert to two separate inequalities and solve both
      const res1 = math.simplify(`${left} ${op1} ${mid}`).toString();
      const res2 = math.simplify(`${mid} ${op2} ${right}`).toString();

      addStep(`ğŸ”¹ Part 1: ${res1}`);
      addStep(`ğŸ”¹ Part 2: ${res2}`);
      addStep(`âœ… Compound inequality is valid if both parts are true.`);
    } catch (e) {
      addStep('âŒ Error solving compound inequality: ' + e.message);
    }
    return;
  }

  // Handle simple inequality
  const ops = ['<=', '>=', '<', '>'];
  let op = ops.find(o => q.includes(o));
  if (!op) return addStep('âŒ No valid inequality operator found (<, >, <=, >=)', true);

  const [lhs, rhs] = q.split(op).map(e => e.trim());

  try {
    const expr = math.simplify(`${lhs} - (${rhs})`).toString();
    const variableMatch = lhs.match(/[a-zA-Z]/g);
    const variable = variableMatch ? variableMatch[0] : 'x';
    const solution = math.solve(q, variable);

    if (solution.length === 0) return addStep('âŒ No solution found.');

    addStep(`âœ… Solution: ${variable} ${op} ${solution[0]}`, true);
  } catch (err) {
    addStep('âŒ Error solving: ' + err.message, true);
  }
}
function solveFractions(q) {
  addStep(`â— Solving Fraction Question: ${q}`);

  // Word problem pattern
  const parts = q.match(/(\d+\/\d+).*(\+|add|and).*(\d+\/\d+)/i);
  if (parts) {
    const f1 = math.fraction(parts[1]);
    const f2 = math.fraction(parts[3]);
    const result = math.add(f1, f2);
    return addStep(`âœ… ${parts[1]} + ${parts[3]} = ${result.n}/${result.d}`, true);
  }

  try {
    // Mixed numbers normalization
    q = q.replace(/(\d+)\s+(\d+)\/(\d+)/g, (_, int, num, den) => {
      return `(${int} + ${num}/${den})`;
    });

    const result = math.evaluate(q);
    addStep(`âœ… Answer: ${result}`, true);
  } catch (e) {
    addStep('âŒ Could not evaluate the expression. Try simpler format like "1/2 + 3/4"', true);
  }
}
function solveDecimals(q) {
  addStep(`ğŸ”¢ Solving Decimal Word Problem: ${q}`);

  // Pattern: amount * hours
  const match = q.match(/([\d.]+)\s*(liters|km|hours|times|rupees)?\s*(per|every)\s*(hour|day|km|time)?.*?(\d+)\s*(hour|day|time|km)?/i);
  if (match) {
    const value = parseFloat(match[1]);
    const times = parseInt(match[5]);
    const total = value * times;
    return addStep(`âœ… Total = ${value} Ã— ${times} = ${total}`, true);
  }

  try {
    const result = math.evaluate(q);
    addStep(`âœ… Answer: ${result}`, true);
  } catch (e) {
    addStep('âŒ Could not evaluate the decimal expression.', true);
  }
}
function solveArithmetic(q) {
  addStep(`ğŸ§® Solving Arithmetic Operation: ${q}`);

  // Natural Language: Add/Subtract/Multiply/Divide
  if (/sum of (\d+) and (\d+)/i.test(q)) {
    const [_, a, b] = q.match(/sum of (\d+) and (\d+)/i);
    return addStep(`âœ… ${a} + ${b} = ${parseInt(a) + parseInt(b)}`, true);
  }

  if (/difference between (\d+) and (\d+)/i.test(q)) {
    const [_, a, b] = q.match(/difference between (\d+) and (\d+)/i);
    return addStep(`âœ… ${a} - ${b} = ${parseInt(a) - parseInt(b)}`, true);
  }

  if (/product of (\d+) and (\d+)/i.test(q)) {
    const [_, a, b] = q.match(/product of (\d+) and (\d+)/i);
    return addStep(`âœ… ${a} Ã— ${b} = ${parseInt(a) * parseInt(b)}`, true);
  }

  if (/quotient of (\d+) and (\d+)/i.test(q)) {
    const [_, a, b] = q.match(/quotient of (\d+) and (\d+)/i);
    return addStep(`âœ… ${a} Ã· ${b} = ${parseInt(a) / parseInt(b)}`, true);
  }

  // Word Problem: "A number is subtracted from X to get Y"
  const pattern = /a number is (added to|subtracted from|multiplied by|divided into) (\d+).*get (\d+)/i;
  const match = q.match(pattern);
  if (match) {
    const op = match[1];
    const known = parseInt(match[2]);
    const result = parseInt(match[3]);
    let unknown;

    if (op.includes('added')) unknown = result - known;
    else if (op.includes('subtracted')) unknown = known - result;
    else if (op.includes('multiplied')) unknown = result / known;
    else if (op.includes('divided')) unknown = known / result;

    return addStep(`âœ… Required number is ${unknown}`, true);
  }

  // Evaluate direct arithmetic input like "78 + 45 - 30"
  try {
    const result = math.evaluate(q);
    addStep(`âœ… Answer: ${result}`, true);
  } catch (e) {
    addStep('âŒ Unable to solve. Use expressions like "sum of 34 and 56" or "45 + 78".', true);
  }
}
function solveArea(q) {
  addStep(`ğŸ“ Solving Area Question: ${q}`);
  const match = q.match(/(square|rectangle|circle|triangle|trapezium|parallelogram).*?(\d+).*?(cm|m).*?(\d+).*?(cm|m)/i);
  if (match) {
    const shape = match[1];
    const a = parseFloat(match[2]);
    const b = parseFloat(match[4]);

    let area;
    if (shape === 'square') area = a * a;
    else if (shape === 'rectangle') area = a * b;
    else if (shape === 'triangle') area = 0.5 * a * b;
    else if (shape === 'parallelogram') area = a * b;
    else if (shape === 'trapezium') area = 0.5 * (a + b) * parseFloat(q.match(/height.*?(\d+)/i)?.[1] || 1);
    else if (shape === 'circle') {
      const radius = parseFloat(q.match(/radius.*?(\d+)/i)?.[1] || a);
      area = Math.PI * radius * radius;
    }

    if (area) return addStep(`âœ… Area of ${shape} = ${area.toFixed(2)} sq units`, true);
  }

  if (q.includes("find height") && q.includes("area")) {
    const match = q.match(/area.*?(\d+).*?base.*?(\d+)/i);
    if (match) {
      const area = parseFloat(match[1]);
      const base = parseFloat(match[2]);
      const height = (2 * area) / base;
      return addStep(`âœ… Height = (2 Ã— ${area}) Ã· ${base} = ${height}`, true);
    }
  }

  addStep("âŒ Couldn't parse. Try 'area of rectangle with length 5 cm and breadth 3 cm'.", true);
}
function solvePerimeter(q) {
  addStep(`ğŸ“ Solving Perimeter Problem: ${q}`);
  const match = q.match(/(square|rectangle|triangle).*?(\d+).*?(and|,)?\s?(\d+)?/i);
  if (match) {
    const shape = match[1];
    const a = parseFloat(match[2]);
    const b = parseFloat(match[4]) || a;
    let result = 0;

    if (shape === 'square') result = 4 * a;
    else if (shape === 'rectangle') result = 2 * (a + b);
    else if (shape === 'triangle') result = a * 3;

    return addStep(`âœ… Perimeter of ${shape} = ${result}`, true);
  }
  addStep("âŒ Try like 'Perimeter of rectangle with length 8 and breadth 5'", true);
}
function solveRationalNumbers(q) {
  addStep(`ğŸ”¢ Solving Rational Number Operation: ${q}`);
  try {
    if (/add|subtract|multiply|divide/i.test(q)) {
      const expr = q.replace(/add|sum|plus/gi, '+')
                    .replace(/subtract|minus/gi, '-')
                    .replace(/multiply|times/gi, '*')
                    .replace(/divide|divided by/gi, '/');
      const result = math.evaluate(expr);
      addStep(`âœ… Result: ${result}`, true);
      return;
    }

    if (/reciprocal of (-?\d+\/\d+)/i.test(q)) {
      const frac = q.match(/-?\d+\/\d+/)[0];
      const [num, den] = frac.split('/').map(Number);
      if (num === 0) return addStep('âŒ Reciprocal of 0 is undefined.');
      return addStep(`âœ… Reciprocal of ${frac} is ${den}/${num}`, true);
    }

    addStep('âŒ Try "Add 2/3 and 3/4" or "Reciprocal of -5/6"', true);
  } catch (e) {
    addStep('âŒ Error in solving rational expression.', true);
  }
}
function solveIntegers(q) {
  addStep(`â• Integer Arithmetic Solver: ${q}`);
  const match = q.match(/(-?\d+)\s*(\+|\-|\*|\/)\s*(-?\d+)/);
  if (match) {
    const [_, a, op, b] = match;
    const result = math.evaluate(`${a} ${op} ${b}`);
    return addStep(`âœ… ${a} ${op} ${b} = ${result}`, true);
  }

  if (/gain|loss|temperature/i.test(q)) {
    addStep('ğŸ“˜ Contextual word problem (gain/loss/temperature) support added soon.');
  } else {
    addStep('âŒ Try: "-3 + 5" or "Add -4 and 7".', true);
  }
}
function solveVolume(q) {
  addStep(`ğŸ“¦ Solving Volume/Surface Area: ${q}`);
  if (/cube/i.test(q)) {
    const side = parseFloat(q.match(/side.*?(\d+)/i)?.[1]);
    if (side) {
      addStep(`âœ… Volume of cube = ${side ** 3}`);
      addStep(`âœ… Surface area = ${6 * (side ** 2)}`);
      return;
    }
  }
  if (/cuboid/i.test(q)) {
    const dims = q.match(/length.*?(\d+).*?breadth.*?(\d+).*?height.*?(\d+)/i);
    if (dims) {
      const [_, l, b, h] = dims.map(Number);
      addStep(`âœ… Volume = ${l * b * h}`);
      addStep(`âœ… Surface Area = ${2 * (l * b + b * h + h * l)}`);
      return;
    }
  }
  if (/cylinder/i.test(q)) {
    const r = parseFloat(q.match(/radius.*?(\d+)/i)?.[1]);
    const h = parseFloat(q.match(/height.*?(\d+)/i)?.[1]);
    if (r && h) {
      const vol = Math.PI * r * r * h;
      const sa = 2 * Math.PI * r * (r + h);
      addStep(`âœ… Volume = Ï€ Ã— rÂ² Ã— h = ${vol.toFixed(2)}`);
      addStep(`âœ… Surface Area = 2Ï€r(r+h) = ${sa.toFixed(2)}`);
      return;
    }
  }

  addStep('âŒ Try "Volume of cube with side 4 cm" or "Cylinder radius 3, height 5".', true);
}
// Topic Logic: Geometry (Expanded)
function solveGeometry(q) {
  addStep(`ğŸ“ Solving Geometry: ${q}`);

  // Coordinate Geometry
  if (/distance.*between.*\((\d+),\s*(\d+)\).*\((\d+),\s*(\d+)\)/i.test(q)) {
    const match = q.match(/\((\d+),\s*(\d+)\).*\((\d+),\s*(\d+)\)/);
    const [x1, y1, x2, y2] = match.slice(1).map(Number);
    const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2).toFixed(2);
    return addStep(`âœ… Distance = ${distance}`);
  }

  // Angle Theorems
  if (/angle.*triangle.*sum/i.test(q)) {
    return addStep(`âœ… The sum of angles in a triangle is always 180Â°.`);
  }

  if (/alternate interior|corresponding angles|transversal/i.test(q)) {
    return addStep(`ğŸ“ Based on angle theorems, corresponding/alternate interior angles are equal if lines are parallel.`);
  }

  // Construction (basic logic explanation)
  if (/construct.*(angle|bisector|perpendicular|triangle)/i.test(q)) {
    return addStep(`ğŸ› ï¸ Constructions require compass and ruler: Use arcs to draw accurate ${RegExp.$1} constructions.`);
  }

  return addStep('ğŸ“š Try using keywords like "coordinate geometry", "angles", or "construct..."');
}
function solveGeometry(q) {
  addStep(`ğŸ“ Geometry Problem: ${q}`);

  // Sum of angles in triangle
  if (/sum.*angles.*triangle/i.test(q)) {
    return addStep('âœ… Sum of angles in a triangle is always 180Â°');
  }

  // Exterior angle
  if (/exterior angle.*triangle.*equal to/i.test(q)) {
    return addStep('âœ… Exterior angle = sum of opposite interior angles');
  }

  // Right-angled triangle with Pythagoras check
  if (/right.*triangle.*sides.*(\d+).*?(\d+).*?(\d+)/i.test(q)) {
    const nums = q.match(/(\d+)/g).map(Number).sort((a, b) => a - b);
    const [a, b, c] = nums;
    const isRight = a * a + b * b === c * c;
    return addStep(`âœ… ${a}Â² + ${b}Â² ${isRight ? '=' : 'â‰ '} ${c}Â² â†’ ${isRight ? 'Right-angled triangle' : 'Not right-angled'}`);
  }

  // Triangle types by side
  if (/triangle.*sides.*?(\d+).*?(\d+).*?(\d+)/i.test(q)) {
    const [a, b, c] = q.match(/(\d+)/g).map(Number);
    if (a === b && b === c) return addStep('âœ… Equilateral triangle: all sides equal');
    if (a === b || b === c || a === c) return addStep('âœ… Isosceles triangle: two sides equal');
    return addStep('âœ… Scalene triangle: all sides different');
  }

  // Circle properties
  if (/circle.*radius.*?(\d+)/i.test(q)) {
    const r = parseFloat(q.match(/radius.*?(\d+)/)[1]);
    addStep(`âœ… Diameter = 2 Ã— ${r} = ${2 * r}`);
    addStep(`âœ… Circumference = 2Ï€ Ã— ${r} = ${(2 * Math.PI * r).toFixed(2)}`);
    addStep(`âœ… Area = Ï€ Ã— ${r}Â² = ${(Math.PI * r * r).toFixed(2)}`);
    return;
  }

  // Shape properties
  if (/quadrilateral|parallelogram|trapezium|rhombus|rectangle|square/i.test(q)) {
    if (/square/i.test(q)) {
      return addStep('âœ… Square: All sides equal, all angles 90Â°, diagonals bisect each other at 90Â°');
    }
    if (/rectangle/i.test(q)) {
      return addStep('âœ… Rectangle: Opposite sides equal, all angles 90Â°, diagonals equal and bisect each other');
    }
    if (/rhombus/i.test(q)) {
      return addStep('âœ… Rhombus: All sides equal, opposite angles equal, diagonals bisect at 90Â°');
    }
    if (/parallelogram/i.test(q)) {
      return addStep('âœ… Parallelogram: Opposite sides equal and parallel, opposite angles equal');
    }
    if (/trapezium/i.test(q)) {
      return addStep('âœ… Trapezium: Only one pair of opposite sides parallel');
    }
    if (/quadrilateral/i.test(q)) {
      return addStep('âœ… Quadrilateral: Any 4-sided closed figure, sum of angles = 360Â°');
    }
  }

  // 3D Geometry keywords
  if (/3d|volume|surface area|faces|edges|vertices/i.test(q)) {
    return addStep('ğŸ§± For 3D shapes, please use Volume & Surface Area topic or try: "cube with edge 5 cm"');
  }

  addStep("ğŸ“š Try: 'Sum of angles in triangle', 'Circle radius 7', 'Type of triangle with sides 3,4,5'", true);
}
function solveSimpleInterest(q) {
  addStep(`ğŸ’° Solving Simple Interest: ${q}`);
  const match = q.match(/(?:principal|P)\s*=?\s*(\d+).*?(?:rate|R)\s*=?\s*(\d+).*?(?:time|T)\s*=?\s*(\d+)/i);
  if (match) {
    const P = parseFloat(match[1]);
    const R = parseFloat(match[2]);
    const T = parseFloat(match[3]);
    const SI = (P * R * T) / 100;
    addStep(`ğŸ“˜ Formula: SI = (P Ã— R Ã— T) / 100`);
    addStep(`âœ… SI = (${P} Ã— ${R} Ã— ${T}) / 100 = ${SI}`);
    return;
  }

  const reverseMatch = q.match(/(?:SI)\s*=?\s*(\d+).*?(?:rate|R)\s*=?\s*(\d+).*?(?:time|T)\s*=?\s*(\d+)/i);
  if (reverseMatch) {
    const SI = parseFloat(reverseMatch[1]);
    const R = parseFloat(reverseMatch[2]);
    const T = parseFloat(reverseMatch[3]);
    const P = (SI * 100) / (R * T);
    addStep(`ğŸ“˜ Reverse formula: P = (SI Ã— 100) / (R Ã— T)`);
    addStep(`âœ… P = (${SI} Ã— 100) / (${R} Ã— ${T}) = ${P}`);
    return;
  }

  addStep("âŒ Please provide values for Principal (P), Rate (R), and Time (T) clearly.");
}
function solveCompoundInterest(q) {
  addStep(`ğŸ’¸ Solving Compound Interest: ${q}`);
  const match = q.match(/(?:principal|P)\s*=?\s*(\d+).*?(?:rate|R)\s*=?\s*(\d+).*?(?:time|T)\s*=?\s*(\d+)/i);
  if (match) {
    const P = parseFloat(match[1]);
    const R = parseFloat(match[2]);
    const T = parseFloat(match[3]);
    const A = P * Math.pow(1 + R / 100, T);
    const CI = A - P;
    addStep(`ğŸ“˜ Formula: CI = P(1 + R/100)^T - P`);
    addStep(`âœ… CI = ${P} Ã— (1 + ${R}/100)^${T} - ${P}`);
    addStep(`âœ… Final Amount = ${A.toFixed(2)}, CI = ${CI.toFixed(2)}`);
    return;
  }

  addStep("âŒ Provide values for Principal (P), Rate (R), and Time (T).");
}
let score = 0;
let totalQuestions = 0;

function addStep(msg) {
  const output = document.getElementById('output');
  output.innerHTML += `<p>${msg}</p>`;
}

function clearOutput() {
  document.getElementById('output').innerHTML = '';
}

function handleInput() {
  clearOutput();
  const topic = document.getElementById('topic').value;
  const q = document.getElementById('question').value.trim();
  switch (topic) {
    case 'mcq': return generateMCQ();
    // Other topics...
    default: addStep('âŒ Unknown topic.');
  }
}

// MCQ Data Bank
const mcqs = [
  // Algebraic Expressions
  {
    question: "What is the simplified form of: 2x + 3x - 5?",
    options: ["5x â€“ 5", "5x", "x", "x â€“ 5"],
    answer: 0
  },
  {
    question: "Which identity is (a + b)^2?",
    options: ["aÂ² + 2ab + bÂ²", "aÂ² â€“ 2ab + bÂ²", "aÂ² + bÂ²", "aÂ² â€“ bÂ²"],
    answer: 0
  },

  // Area
  {
    question: "What is the area of a rectangle with length 8 cm and breadth 5 cm?",
    options: ["13 cmÂ²", "40 cmÂ²", "20 cmÂ²", "30 cmÂ²"],
    answer: 1
  },
  {
    question: "Area of a circle with radius 7 cm is?",
    options: ["154 cmÂ²", "49 cmÂ²", "44 cmÂ²", "100 cmÂ²"],
    answer: 0
  },

  // Volume & Surface Area
  {
    question: "Volume of a cube with edge 5 cm is?",
    options: ["125 cmÂ³", "100 cmÂ³", "25 cmÂ³", "225 cmÂ³"],
    answer: 0
  },
  {
    question: "Surface area of a cube with side 4 cm is?",
    options: ["64 cmÂ²", "96 cmÂ²", "48 cmÂ²", "100 cmÂ²"],
    answer: 1
  },

  // Exponents
  {
    question: "Which law of exponent is used in: aâ´ Ã— aÂ³ = aâ·?",
    options: ["Power of power", "Product of powers", "Quotient rule", "None"],
    answer: 1
  },
  {
    question: "10Â³ means:",
    options: ["10", "30", "100", "1000"],
    answer: 3
  },

  // Percentage
  {
    question: "25% as a fraction is:",
    options: ["1/2", "2/5", "1/4", "1/5"],
    answer: 2
  },
  {
    question: "What is 30% of 200?",
    options: ["30", "50", "60", "80"],
    answer: 2
  },

  // Factorisation
  {
    question: "Factorisation of xÂ² - 9 is:",
    options: ["(x + 3)(x + 3)", "(x - 3)(x - 3)", "(x - 3)(x + 3)", "None"],
    answer: 2
  },
  {
    question: "Which is the correct factor of 4xÂ² + 4x + 1?",
    options: ["(2x + 1)Â²", "(x + 1)Â²", "(2x + 1)(2x - 1)", "(4x + 1)(x + 1)"],
    answer: 0
  },

  // Geometry
  {
    question: "How many angles does a hexagon have?",
    options: ["6", "5", "8", "4"],
    answer: 0
  },
  {
    question: "What is the sum of angles in a triangle?",
    options: ["90Â°", "180Â°", "360Â°", "270Â°"],
    answer: 1
  },

  // Data Handling
  {
    question: "What does a pie chart represent?",
    options: ["Bars", "Fractions", "Pictures", "None"],
    answer: 1
  },
  {
    question: "Which graph shows change over time?",
    options: ["Bar graph", "Line graph", "Pie chart", "Pictograph"],
    answer: 1
  },

  // Profit & Loss
  {
    question: "Profit is calculated using:",
    options: ["SP - CP", "CP - SP", "SP Ã— CP", "None"],
    answer: 0
  },
  {
    question: "Loss is calculated using:",
    options: ["CP - SP", "SP - CP", "SP + CP", "None"],
    answer: 0
  }
];

let currentQuestionIndex = 0;

function generateMCQ() {
  clearOutput();
  if (currentQuestionIndex >= mcqs.length) {
    addStep(`âœ… Quiz completed. Final Score: ${score}/${totalQuestions}`);
    return;
  }

  const mcq = mcqs[currentQuestionIndex];
  totalQuestions++;

  const optionsHTML = mcq.options.map((opt, i) =>
    `<button onclick="checkAnswer(${i})">${opt}</button>`
  ).join('<br>');

  document.getElementById('output').innerHTML = `
    <h3>ğŸ“˜ Q${currentQuestionIndex + 1}: ${mcq.question}</h3>
    ${optionsHTML}
  `;
}

function checkAnswer(selectedIndex) {
  const mcq = mcqs[currentQuestionIndex];
  if (selectedIndex === mcq.answer) {
    score++;
    addStep('âœ… Correct!');
  } else {
    addStep(`âŒ Incorrect. Correct answer: ${mcq.options[mcq.answer]}`);
  }
  currentQuestionIndex++;
  setTimeout(() => generateMCQ(), 1000);
}

// Include 'mcq' in dropdown <select> with label "MCQ Quiz"
// <option value="mcq">MCQ Quiz</option>
  // logic.js â€“ Full Script with MCQ Generator, Subjective Questions and Scoring

let score = 0;
let totalQuestions = 0;

function addStep(msg) {
  const output = document.getElementById('output');
  output.innerHTML += `<p>${msg}</p>`;
}

function clearOutput() {
  document.getElementById('output').innerHTML = '';
}

function handleInput() {
  clearOutput();
  const topic = document.getElementById('topic').value;
  const q = document.getElementById('question').value.trim();
  switch (topic) {
    case 'mcq': return generateMCQ();
    case 'subjective': return generateSubjective();
    default: addStep('âŒ Unknown topic.');
  }
}

// MCQ Data Bank
const mcqs = [
  // [...MCQs as before, unchanged...]
];

let currentQuestionIndex = 0;

function generateMCQ() {
  clearOutput();
  if (currentQuestionIndex >= mcqs.length) {
    addStep(`âœ… Quiz completed. Final Score: ${score}/${totalQuestions}`);
    return;
  }

  const mcq = mcqs[currentQuestionIndex];
  totalQuestions++;

  const optionsHTML = mcq.options.map((opt, i) =>
    `<button onclick="checkAnswer(${i})">${opt}</button>`
  ).join('<br>');

  document.getElementById('output').innerHTML = `
    <h3>ğŸ“˜ Q${currentQuestionIndex + 1}: ${mcq.question}</h3>
    ${optionsHTML}
  `;
}

function checkAnswer(selectedIndex) {
  const mcq = mcqs[currentQuestionIndex];
  if (selectedIndex === mcq.answer) {
    score++;
    addStep('âœ… Correct!');
  } else {
    addStep(`âŒ Incorrect. Correct answer: ${mcq.options[mcq.answer]}`);
  }
  currentQuestionIndex++;
  setTimeout(() => generateMCQ(), 1000);
}

// Subjective Questions with Simple Keyword Checking
const subjectiveQuestions = [
  {
    question: "A man sells a shirt for Rs. 480 and gains 20%. Find the cost price.",
    expectedKeywords: ["cost", "price", "400"]
  },
  {
    question: "The perimeter of a rectangle is 60 cm. If its length is 20 cm, find the breadth and area.",
    expectedKeywords: ["breadth", "10", "area", "200"]
  },
  {
    question: "A student scored 75%, 80%, and 85% in three tests. What is the average score?",
    expectedKeywords: ["average", "score", "80"]
  },
  {
    question: "If a cube has a surface area of 96 cmÂ², what is the length of its edge?",
    expectedKeywords: ["edge", "4"]
  },
  {
    question: "A man is 4 times as old as his son. In 10 years, he will be twice as old. Find their ages.",
    expectedKeywords: ["man", "son", "40", "10"]
  },
  {
    question: "Find the area of a trapezium with parallel sides 8 cm and 5 cm, and height 4 cm.",
    expectedKeywords: ["area", "trapezium", "26"]
  }
];

let currentSubjectiveIndex = 0;

function generateSubjective() {
  clearOutput();
  if (currentSubjectiveIndex >= subjectiveQuestions.length) {
    addStep(`âœ… Subjective Quiz completed. Final Score: ${score}/${totalQuestions}`);
    return;
  }

  const subj = subjectiveQuestions[currentSubjectiveIndex];
  totalQuestions++;

  document.getElementById('output').innerHTML = `
    <h3>ğŸ“ Q${currentSubjectiveIndex + 1}: ${subj.question}</h3>
    <textarea id="userAnswer" rows="4" cols="50" placeholder="Type your answer here..."></textarea><br>
    <button onclick="checkSubjectiveAnswer()">Submit Answer</button>
  `;
}

function checkSubjectiveAnswer() {
  const userAnswer = document.getElementById('userAnswer').value.toLowerCase();
  const subj = subjectiveQuestions[currentSubjectiveIndex];
  const matched = subj.expectedKeywords.every(k => userAnswer.includes(k));
  if (matched) {
    score++;
    addStep('âœ… Well done! Your answer seems correct.');
  } else {
    addStep('âŒ Your answer seems incorrect. Please check your approach.');
  }
  currentSubjectiveIndex++;
  setTimeout(() => generateSubjective(), 1500);
}

// Include in dropdown
// <option value="mcq">MCQ Quiz</option>
// <option value="subjective">Subjective Word Problems</option>


}
</script>
</body>
</html>
