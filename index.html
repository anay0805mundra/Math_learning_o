<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Math Learning-o</title>
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@v2.1.5/dist/tesseract.min.js"></script>
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<style>
  body { font-family: Arial, sans-serif; margin: 20px; background:#f9f9f9; }
  h1 { color: #2c3e50; }
  #steps { border: 1px solid #ccc; background: white; padding: 15px; height: 200px; overflow-y: auto; margin-top: 15px; }
  button, select, input, textarea { font-size: 1rem; margin: 5px 0; padding: 7px; }
  #graph { margin-top: 20px; width: 100%; max-width: 600px; height: 400px; }
  .error { color: red; }
  .bold { font-weight: bold; }
</style>
</head>
<body>

<h1>Math Learning-o</h1>

<label for="topic">Select Topic:</label><br/>
<select id="topic" style="width: 300px;">
  <option value="">-- Choose Topic --</option>
  <option value="simpleInterest">Simple Interest</option>
  <option value="compoundInterest">Compound Interest</option>
  <option value="linearEquation">Linear Equation (1 variable)</option>
  <option value="quadraticEquation">Quadratic Equation</option>
  <option value="polynomials">Polynomials</option>
  <option value="inequalities">Inequalities</option>
  <option value="algebraicExpressions">Algebraic Expressions</option>
  <option value="exponents">Exponents</option>
  <option value="rationalNumbers">Rational Numbers</option>
  <option value="squaresCubesRoots">Squares, Cubes & Roots</option>
  <option value="integers">Integers</option>
  <option value="fractions">Fractions</option>
  <option value="decimals">Decimals</option>
  <option value="probability">Probability</option>
  <option value="percentage">Percentage</option>
  <option value="perimeter">Perimeter</option>
  <option value="area">Area</option>
  <option value="volumeSurface">Volume & Surface Area</option>
  <option value="geometryQA">Geometry Q&A</option>
  <option value="graphing">Graphing (Plot functions)</option>
</select><br/>

<label for="question">Enter your math question:</label><br/>
<textarea id="question" rows="4" cols="60" placeholder="Type your question or math expression here..."></textarea><br/>

<label for="imageInput">Or upload a math problem image:</label><br/>
<input type="file" id="imageInput" accept="image/*" /><br/>

<button onclick="startVoiceInput()">ðŸŽ¤ Voice Input</button>
<button onclick="solve()">Solve</button>
<button onclick="clearOutput()">Clear</button>

<div id="steps"></div>

<div id="graph"></div>

<script>
// Utility to add step to output box
function addStep(text, isFinal=false) {
  const steps = document.getElementById('steps');
  const p = document.createElement('p');
  if(isFinal) p.classList.add('bold');
  p.textContent = text;
  steps.appendChild(p);
  steps.scrollTop = steps.scrollHeight;
}
function clearOutput() {
  document.getElementById('steps').innerHTML = '';
  document.getElementById('graph').innerHTML = '';
}

// Image processing with Tesseract OCR
document.getElementById('imageInput').addEventListener('change', (e) => {
  clearOutput();
  const file = e.target.files[0];
  if(!file) return;
  addStep('ðŸ–¼ï¸ Processing imageâ€¦');
  Tesseract.recognize(file, 'eng', {
    logger: m => {
      if(m.status === 'recognizing text') addStep('â€¦ OCR progress: ' + Math.round(m.progress * 100) + '%');
    }
  }).then(({ data: { text }}) => {
    const cleanText = text.trim().replace(/\n/g, ' ');
    document.getElementById('question').value = cleanText;
    addStep('ðŸ“ OCR extracted text: ' + cleanText, true);
  }).catch(err => addStep('OCR error: ' + err.message, true));
});

// Voice input using Web Speech API
function startVoiceInput() {
  if (!('webkitSpeechRecognition' in window)) {
    alert('Speech Recognition not supported in this browser.');
    return;
  }
  clearOutput();
  addStep('ðŸŽ™ï¸ Listening... Speak now.');
  const recognition = new webkitSpeechRecognition();
  recognition.lang = 'en-US';
  recognition.interimResults = false;
  recognition.maxAlternatives = 1;
  recognition.start();

  recognition.onresult = (event) => {
    const spokenText = event.results[0][0].transcript;
    document.getElementById('question').value = spokenText;
    addStep('ðŸŽ™ï¸ Recognized text: ' + spokenText, true);
  };
  recognition.onerror = (event) => {
    addStep('Speech recognition error: ' + event.error, true);
  };
}

// Main solver dispatcher
function solve() {
  clearOutput();
  const topic = document.getElementById('topic').value;
  const question = document.getElementById('question').value.trim();

  if (!topic) return addStep('âš ï¸ Please select a topic.', true);
  if (!question) return addStep('âš ï¸ Please enter or upload a question.', true);

  try {
    switch(topic) {
      case 'simpleInterest': solveSimpleInterest(question); break;
      case 'compoundInterest': solveCompoundInterest(question); break;
      case 'linearEquation': solveLinearEquation(question); break;
      case 'quadraticEquation': solveQuadraticEquation(question); break;
      case 'polynomials': solvePolynomials(question); break;
      case 'inequalities': solveInequalities(question); break;
      case 'algebraicExpressions': solveAlgebraicExpressions(question); break;
      case 'exponents': solveExponents(question); break;
      case 'rationalNumbers': solveRationalNumbers(question); break;
      case 'squaresCubesRoots': solveSquaresCubesRoots(question); break;
      case 'integers': solveIntegers(question); break;
      case 'fractions': solveFractions(question); break;
      case 'decimals': solveDecimals(question); break;
      case 'probability': solveProbability(question); break;
      case 'percentage': solvePercentage(question); break;
      case 'perimeter': solvePerimeter(question); break;
      case 'area': solveArea(question); break;
      case 'volumeSurface': solveVolumeSurface(question); break;
      case 'geometryQA': solveGeometryQA(question); break;
      case 'graphing': solveGraphing(question); break;
      default:
        addStep('âš ï¸ Solver not implemented for this topic yet.', true);
    }
  } catch (e) {
    addStep('Error during solving: ' + e.message, true);
    console.error(e);
  }
}

// ====================
// === SOLVER FUNCTIONS
// ====================

// SIMPLE INTEREST
function solveSimpleInterest(q) {
  const Pm = q.match(/P\s*=\s*([\d.]+)/i);
  const Rm = q.match(/R\s*=\s*([\d.]+)/i);
  const Tm = q.match(/T\s*=\s*([\d.]+)/i);
  if(!Pm || !Rm || !Tm) return addStep("âš ï¸ Please provide P, R, and T in format: P=number R=number T=number", true);
  const P = parseFloat(Pm[1]);
  const R = parseFloat(Rm[1]);
  const T = parseFloat(Tm[1]);
  addStep(`Given: Principal (P) = ${P}, Rate (R) = ${R}%, Time (T) = ${T} years`);
  const SI = (P * R * T) / 100;
  addStep(`Simple Interest = (P Ã— R Ã— T) / 100 = (${P} Ã— ${R} Ã— ${T}) / 100 = ${SI}`, true);
}

// COMPOUND INTEREST
function solveCompoundInterest(q) {
  const Pm = q.match(/P\s*=\s*([\d.]+)/i);
  const Rm = q.match(/R\s*=\s*([\d.]+)/i);
  const Tm = q.match(/T\s*=\s*([\d.]+)/i);
  const nm = q.match(/n\s*=\s*([\d.]+)/i);
  if(!Pm || !Rm || !Tm) return addStep("âš ï¸ Please provide P, R, and T in format: P=number R=number T=number", true);
  const P = parseFloat(Pm[1]);
  const R = parseFloat(Rm[1]) / 100;
  const T = parseFloat(Tm[1]);
  const n = nm ? parseFloat(nm[1]) : 1; // default compounding yearly
  addStep(`Given: Principal (P) = ${P}, Rate (R) = ${R * 100}%, Time (T) = ${T} years, Compounded n = ${n} times per year`);
  const A = P * Math.pow(1 + R / n, n * T);
  const CI = A - P;
  addStep(`Amount (A) = P (1 + R/n)^(nT) = ${P} Ã— (1 + ${R}/${n})^(${n}Ã—${T}) = ${A.toFixed(2)}`);
  addStep(`Compound Interest = A - P = ${A.toFixed(2)} - ${P} = ${CI.toFixed(2)}`, true);
}

// LINEAR EQUATION (1 variable)
function solveLinearEquation(q) {
  // Example input: 3x + 2 = 11
  addStep("Solving linear equation:");
  let eq = q.replace(/\s+/g, '');
  const sides = eq.split('=');
  if(sides.length !== 2) return addStep("âš ï¸ Please provide an equation with one '=' sign.", true);
  const left = sides[0];
  const right = sides[1];

  // Extract coefficients using regex (simple)
  // Handle form ax + b = c
  const regex = /^([+-]?[\d\.]*)x([+-][\d\.]+)?$/i;
  let a=0,b=0;

  // Attempt to parse left side
  const match = left.match(/^([+-]?[\d\.]*)x([+-][\d\.]+)?$/i);
  if(!match) return addStep("âš ï¸ Equation format not recognized. Use ax + b = c format.", true);
  a = match[1] === '' || match[1] === '+' ? 1 : (match[1] === '-' ? -1 : parseFloat(match[1]));
  b = match[2] ? parseFloat(match[2]) : 0;
  const c = parseFloat(right);

  addStep(`Equation in form: ${a}x + (${b}) = ${c}`);
  addStep(`Step 1: Subtract ${b} from both sides: ${a}x = ${c} - (${b}) = ${c - b}`);
  const x = (c - b) / a;
  addStep(`Step 2: Divide both sides by ${a}: x = ${x}`, true);
}

// QUADRATIC EQUATION axÂ² + bx + c = 0
function solveQuadraticEquation(q) {
  // Extract coefficients a,b,c from a simple input
  addStep("Solving quadratic equation:");
  // Simplified extraction:
  // Input like: 2x^2 + 3x - 5 = 0 or 2x^2+3x-5=0
  let eq = q.replace(/\s+/g, '').replace(/=0$/, '');
  // Match a, b, c
  // a: coefficient before x^2
  const aMatch = eq.match(/^([+-]?[\d\.]*)x\^2/);
  if(!aMatch) return addStep("âš ï¸ Equation must contain x^2 term.", true);
  let a = aMatch[1];
  if(a === '' || a === '+') a = 1;
  else if(a === '-') a = -1;
  else a = parseFloat(a);

  // b term
  const bMatch = eq.match(/[+-]([\d\.]+)x(?!\^)/);
  let b = 0;
  if(bMatch) {
    const fullB = eq.match(/[+-][\d\.]+x(?!\^)/)[0];
    b = parseFloat(fullB);
  }

  // c term
  const cMatch = eq.match(/([+-][\d\.]+)(?![x\^])/g);
  let c = 0;
  if(cMatch) {
    c.forEach ? cMatch.forEach(v => c += parseFloat(v)) : c = parseFloat(cMatch[0]);
    // Just take the last match for simplicity
    c = parseFloat(cMatch[cMatch.length - 1]);
  }

  addStep(`Coefficients: a=${a}, b=${b}, c=${c}`);

  const discriminant = b*b - 4*a*c;
  addStep(`Discriminant D = bÂ² - 4ac = (${b})Â² - 4Ã—${a}Ã—${c} = ${discriminant}`);

  if(discriminant < 0) {
    addStep("No real roots (discriminant < 0).", true);
    return;
  }
  const sqrtD = Math.sqrt(discriminant);
  const root1 = (-b + sqrtD) / (2*a);
  const root2 = (-b - sqrtD) / (2*a);

  addStep(`Root 1 = (-b + âˆšD) / 2a = (${ -b } + ${sqrtD.toFixed(3)}) / ${2*a} = ${root1.toFixed(3)}`);
  addStep(`Root 2 = (-b - âˆšD) / 2a = (${ -b } - ${sqrtD.toFixed(3)}) / ${2*a} = ${root2.toFixed(3)}`, true);
}

// POLYNOMIALS (simple factorization or evaluation)
function solvePolynomials(q) {
  addStep("Polynomial solver coming soon!", true);
}

// INEQUALITIES (basic handling)
function solveInequalities(q) {
  addStep("Inequalities solver coming soon!", true);
}

// ALGEBRAIC EXPRESSIONS (simplification)
function solveAlgebraicExpressions(q) {
  addStep("Algebraic expressions solver coming soon!", true);
}

// EXPONENTS (basic calculations)
function solveExponents(q) {
  // Expect input like: 2^3 or 5^2
  addStep("Calculating exponent:");
  const m = q.match(/([\d\.]+)\^([\d\.]+)/);
  if(!m) return addStep("âš ï¸ Please enter exponent expression like '2^3'.", true);
  const base = parseFloat(m[1]);
  const exp = parseFloat(m[2]);
  const result = Math.pow(base, exp);
  addStep(`${base}^${exp} = ${result}`, true);
}

// RATIONAL NUMBERS (operations)
function solveRationalNumbers(q) {
  addStep("Rational numbers solver coming soon!", true);
}

// SQUARES, CUBES & ROOTS
function solveSquaresCubesRoots(q) {
  addStep("Squares, cubes, and roots calculation:");

  // Remove spaces and to lower
  const str = q.toLowerCase().replace(/\s+/g, '');

  // Square root
  let m = str.match(/sqrt\(([\d\.]+)\)/);
  if(m) {
    const val = parseFloat(m[1]);
    const res = Math.sqrt(val);
    addStep(`âˆš${val} = ${res}`, true);
    return;
  }

  // Cube root: cube root 27 or cbrt(27)
  m = str.match(/cbrt\(([\d\.]+)\)/);
  if(m) {
    const val = parseFloat(m[1]);
    const res = Math.cbrt(val);
    addStep(`Â³âˆš${val} = ${res}`, true);
    return;
  }

  m = str.match(/cuberoot([\d\.]+)/);
  if(m) {
    const val = parseFloat(m[1]);
    const res = Math.cbrt(val);
    addStep(`Â³âˆš${val} = ${res}`, true);
    return;
  }

  // Squares: 5^2 or 5 squared
  m = str.match(/([\d\.]+)\^2/);
  if(m) {
    const val = parseFloat(m[1]);
    const res = val*val;
    addStep(`${val}^2 = ${res}`, true);
    return;
  }
  if(str.includes('squared')) {
    m = str.match(/([\d\.]+)squared/);
    if(m) {
      const val = parseFloat(m[1]);
      const res = val*val;
      addStep(`${val} squared = ${res}`, true);
      return;
    }
  }

  // Cubes: 3^3 or 3 cubed
  m = str.match(/([\d\.]+)\^3/);
  if(m) {
    const val = parseFloat(m[1]);
    const res = val*val*val;
    addStep(`${val}^3 = ${res}`, true);
    return;
  }
  if(str.includes('cubed')) {
    m = str.match(/([\d\.]+)cubed/);
    if(m) {
      const val = parseFloat(m[1]);
      const res = val*val*val;
      addStep(`${val} cubed = ${res}`, true);
      return;
    }
  }

  addStep("âš ï¸ Unable to parse input for squares, cubes, or roots. Try formats like sqrt(16), 3^2, 4 cubed, cbrt(27).", true);
}

// INTEGERS (basic)
function solveIntegers(q) {
  addStep("Integers solver coming soon!", true);
}

// FRACTIONS (simplify or add)
function solveFractions(q) {
  addStep("Fractions solver coming soon!", true);
}

// DECIMALS (basic)
function solveDecimals(q) {
  addStep("Decimals solver coming soon!", true);
}

// PROBABILITY (basic)
function solveProbability(q) {
  addStep("Probability solver coming soon!", true);
}

// PERCENTAGE (basic)
function solvePercentage(q) {
  addStep("Percentage solver coming soon!", true);
}

// PERIMETER (basic)
function solvePerimeter(q) {
  addStep("Perimeter solver coming soon!", true);
}

// AREA (basic)
function solveArea(q) {
  addStep("Area solver coming soon!", true);
}

// VOLUME & SURFACE AREA (basic)
function solveVolumeSurface(q) {
  addStep("Volume & Surface Area solver coming soon!", true);
}

// GEOMETRY Q&A (basic)
function solveGeometryQA(q) {
  addStep("Geometry Q&A solver coming soon!", true);
}

// GRAPHING (Plot function y=f(x))
function solveGraphing(q) {
  addStep("Graphing function y = f(x):");
  try {
    // Remove 'graph' or similar from query
    let expr = q.replace(/graph|plot|function|y=|f\(x\)/gi, '').trim();
    if(!expr) return addStep("âš ï¸ Please enter a function expression, e.g., y = x^2 + 3x + 2", true);

    // Replace '^' with '**' for JS evaluation
    expr = expr.replace(/\^/g, '**');

    addStep(`Plotting: y = ${expr}`);

    // Generate data points
    const xValues = [];
    const yValues = [];
    for(let x = -10; x <= 10; x += 0.5) {
      let y = 0;
      try {
        y = eval(expr.replace(/x/g, `(${x})`));
        if(typeof y !== 'number' || !isFinite(y)) y = NaN;
      } catch {
        y = NaN;
      }
      xValues.push(x);
      yValues.push(y);
    }

    const data = [{
      x: xValues,
      y: yValues,
      mode: 'lines+markers',
      type: 'scatter',
      line: {shape: 'spline', smoothing: 1.3},
      name: 'y = ' + expr
    }];

    const layout = {
      title: 'Graph of y = ' + expr,
      xaxis: {title: 'x'},
      yaxis: {title: 'y'}
    };

    Plotly.newPlot('graph', data, layout);
    addStep('Graph plotted successfully.', true);
  } catch (e) {
    addStep('Error plotting graph: ' + e.message, true);
  }
}

</script>

</body>
</html>
