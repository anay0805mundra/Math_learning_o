<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Math Learning-o</title>
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@v2.1.5/dist/tesseract.min.js"></script>
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<style>
  body { font-family: Arial, sans-serif; margin: 20px; background:#f9f9f9; }
  h1 { color: #2c3e50; }
  #steps { border: 1px solid #ccc; background: white; padding: 15px; height: 200px; overflow-y: auto; margin-top: 15px; }
  button, select, input, textarea { font-size: 1rem; margin: 5px 0; padding: 7px; }
  #graph { margin-top: 20px; width: 100%; max-width: 600px; height: 400px; }
  .error { color: red; }
  .bold { font-weight: bold; }
</style>
</head>
<body>

<h1>Math Learning-o</h1>

<label for="topic">Select Topic:</label><br/>
<select id="topic" style="width: 300px;">
  <option value="">-- Choose Topic --</option>
  <option value="simpleInterest">Simple Interest</option>
  <option value="compoundInterest">Compound Interest</option>
  <option value="linearEquation">Linear Equation (1 variable)</option>
  <option value="quadraticEquation">Quadratic Equation</option>
  <option value="polynomials">Polynomials</option>
  <option value="inequalities">Inequalities</option>
  <option value="algebraicExpressions">Algebraic Expressions</option>
  <option value="exponents">Exponents</option>
  <option value="rationalNumbers">Rational Numbers</option>
  <option value="squaresCubesRoots">Squares, Cubes & Roots</option>
  <option value="integers">Integers</option>
  <option value="fractions">Fractions</option>
  <option value="decimals">Decimals</option>
  <option value="probability">Probability</option>
  <option value="percentage">Percentage</option>
  <option value="perimeter">Perimeter</option>
  <option value="area">Area</option>
  <option value="volumeSurface">Volume & Surface Area</option>
  <option value="geometryQA">Geometry Q&A</option>
  <option value="graphing">Graphing (Plot functions)</option>
</select><br/>

<label for="question">Enter your math question:</label><br/>
<textarea id="question" rows="4" cols="60" placeholder="Type your question or math expression here..."></textarea><br/>

<label for="imageInput">Or upload a math problem image:</label><br/>
<input type="file" id="imageInput" accept="image/*" /><br/>

<button onclick="startVoiceInput()">üé§ Voice Input</button>
<button onclick="solve()">Solve</button>
<button onclick="clearOutput()">Clear</button>

<div id="steps"></div>

<div id="graph"></div>

<script>
// Utility to add step to output box
function addStep(text, isFinal=false) {
  const steps = document.getElementById('steps');
  const p = document.createElement('p');
  if(isFinal) p.classList.add('bold');
  p.textContent = text;
  steps.appendChild(p);
  steps.scrollTop = steps.scrollHeight;
}
function clearOutput() {
  document.getElementById('steps').innerHTML = '';
  document.getElementById('graph').innerHTML = '';
}

// Image processing with Tesseract OCR
document.getElementById('imageInput').addEventListener('change', (e) => {
  clearOutput();
  const file = e.target.files[0];
  if(!file) return;
  addStep('üñºÔ∏è Processing image‚Ä¶');
  Tesseract.recognize(file, 'eng', {
    logger: m => {
      if(m.status === 'recognizing text') addStep('‚Ä¶ OCR progress: ' + Math.round(m.progress * 100) + '%');
    }
  }).then(({ data: { text }}) => {
    const cleanText = text.trim().replace(/\n/g, ' ');
    document.getElementById('question').value = cleanText;
    addStep('üìù OCR extracted text: ' + cleanText, true);
  }).catch(err => addStep('OCR error: ' + err.message, true));
});

// Voice input using Web Speech API
function startVoiceInput() {
  if (!('webkitSpeechRecognition' in window)) {
    alert('Speech Recognition not supported in this browser.');
    return;
  }
  clearOutput();
  addStep('üéôÔ∏è Listening... Speak now.');
  const recognition = new webkitSpeechRecognition();
  recognition.lang = 'en-US';
  recognition.interimResults = false;
  recognition.maxAlternatives = 1;
  recognition.start();

  recognition.onresult = (event) => {
    const spokenText = event.results[0][0].transcript;
    document.getElementById('question').value = spokenText;
    addStep('üéôÔ∏è Recognized text: ' + spokenText, true);
  };
  recognition.onerror = (event) => {
    addStep('Speech recognition error: ' + event.error, true);
  };
}

// Main solver dispatcher
function solve() {
  clearOutput();
  const topic = document.getElementById('topic').value;
  const question = document.getElementById('question').value.trim();

  if (!topic) return addStep('‚ö†Ô∏è Please select a topic.', true);
  if (!question) return addStep('‚ö†Ô∏è Please enter or upload a question.', true);

  try {
    switch(topic) {
      case 'simpleInterest': solveSimpleInterest(question); break;
      case 'compoundInterest': solveCompoundInterest(question); break;
      case 'linearEquation': solveLinearEquation(question); break;
      case 'quadraticEquation': solveQuadraticEquation(question); break;
      case 'polynomials': solvePolynomials(question); break;
      case 'inequalities': solveInequalities(question); break;
      case 'algebraicExpressions': solveAlgebraicExpressions(question); break;
      case 'exponents': solveExponents(question); break;
      case 'rationalNumbers': solveRationalNumbers(question); break;
      case 'squaresCubesRoots': solveSquaresCubesRoots(question); break;
      case 'integers': solveIntegers(question); break;
      case 'fractions': solveFractions(question); break;
      case 'decimals': solveDecimals(question); break;
      case 'probability': solveProbability(question); break;
      case 'percentage': solvePercentage(question); break;
      case 'perimeter': solvePerimeter(question); break;
      case 'area': solveArea(question); break;
      case 'volumeSurface': solveVolumeSurface(question); break;
      case 'geometryQA': solveGeometryQA(question); break;
      case 'graphing': solveGraphing(question); break;
      default:
        addStep('‚ö†Ô∏è Solver not implemented for this topic yet.', true);
    }
  } catch (e) {
    addStep('Error during solving: ' + e.message, true);
    console.error(e);
  }
}

// ====================
// === SOLVER FUNCTIONS
// ====================

// SIMPLE INTEREST
function solveSimpleInterest(q) {
  const Pm = q.match(/P\s*=\s*([\d.]+)/i);
  const Rm = q.match(/R\s*=\s*([\d.]+)/i);
  const Tm = q.match(/T\s*=\s*([\d.]+)/i);
  if(!Pm || !Rm || !Tm) return addStep("‚ö†Ô∏è Please provide P, R, and T in format: P=number R=number T=number", true);
  const P = parseFloat(Pm[1]);
  const R = parseFloat(Rm[1]);
  const T = parseFloat(Tm[1]);
  const SI = (P * R * T) / 100;
  addStep(`Simple Interest = (P √ó R √ó T) / 100 = (${P} √ó ${R} √ó ${T}) / 100 = ${SI}`, true);
}

// COMPOUND INTEREST
function solveCompoundInterest(q) {
  // Example input: P=1000 R=5 T=2 n=4 (quarterly)
  const Pm = q.match(/P\s*=\s*([\d.]+)/i);
  const Rm = q.match(/R\s*=\s*([\d.]+)/i);
  const Tm = q.match(/T\s*=\s*([\d.]+)/i);
  const nm = q.match(/n\s*=\s*(\d+)/i);
  if(!Pm || !Rm || !Tm || !nm) return addStep("‚ö†Ô∏è Please provide P, R, T, and n in format: P=number R=number T=number n=number", true);
  const P = parseFloat(Pm[1]);
  const R = parseFloat(Rm[1]);
  const T = parseFloat(Tm[1]);
  const n = parseInt(nm[1]);
  const A = P * Math.pow(1 + (R / 100) / n, n * T);
  const CI = A - P;
  addStep(`Compound Interest = A - P`, false);
  addStep(`A = P(1 + R/(100√ón))^(n√óT) = ${P} √ó (1 + ${R}/(100√ó${n}))^(${n}√ó${T}) = ${A.toFixed(2)}`, false);
  addStep(`Compound Interest = ${A.toFixed(2)} - ${P} = ${CI.toFixed(2)}`, true);
}

// LINEAR EQUATION ax + b = 0
function solveLinearEquation(q) {
  // parse something like "2x + 3 = 0" or "x - 4 = 0"
  const m = q.match(/([+-]?\d*)x\s*([+-]\s*\d+)?\s*=\s*0/);
  if(!m) return addStep("‚ö†Ô∏è Please enter linear equation in format: ax + b = 0", true);
  let a = m[1];
  let b = m[2];
  if(a === '' || a === '+') a = 1;
  else if(a === '-') a = -1;
  else a = parseFloat(a);
  if(!b) b = 0;
  else b = parseFloat(b.replace(/\s+/g, ''));
  const x = -b / a;
  addStep(`Solving ${a}x + ${b} = 0`, false);
  addStep(`x = -b / a = -(${b}) / ${a} = ${x}`, true);
}

// QUADRATIC EQUATION ax^2 + bx + c = 0
function solveQuadraticEquation(q) {
  // parse ax^2 + bx + c = 0, example: 1x^2 + -3x + 2 = 0
  const m = q.match(/([+-]?\d*)x\^2\s*([+-]\s*\d*)x\s*([+-]\s*\d+)?\s*=\s*0/);
  if(!m) return addStep("‚ö†Ô∏è Please enter quadratic equation in format: ax^2 + bx + c = 0", true);
  let a = m[1];
  let b = m[2];
  let c = m[3];
  if(a === '' || a === '+') a = 1;
  else if(a === '-') a = -1;
  else a = parseFloat(a);
  if(!b) b = 0;
  else b = parseFloat(b.replace(/\s+/g, ''));
  if(!c) c = 0;
  else c = parseFloat(c.replace(/\s+/g, ''));
  addStep(`Given quadratic equation: ${a}x¬≤ + ${b}x + ${c} = 0`, false);
  const D = b*b - 4*a*c;
  addStep(`Discriminant D = b¬≤ - 4ac = (${b})¬≤ - 4 √ó ${a} √ó ${c} = ${D}`, false);
  if(D < 0) {
    addStep("No real roots.", true);
  } else if(D === 0) {
    const x = -b/(2*a);
    addStep(`One real root x = -b/(2a) = -${b}/(2√ó${a}) = ${x}`, true);
  } else {
    const x1 = (-b + Math.sqrt(D)) / (2*a);
    const x2 = (-b - Math.sqrt(D)) / (2*a);
    addStep(`Two real roots:`, false);
    addStep(`x‚ÇÅ = (-b + ‚àöD) / 2a = (${ -b } + ‚àö${D}) / (2 √ó ${a}) = ${x1}`, false);
    addStep(`x‚ÇÇ = (-b - ‚àöD) / 2a = (${ -b } - ‚àö${D}) / (2 √ó ${a}) = ${x2}`, true);
  }
}

// POLYNOMIALS - simple evaluation or simplification
function solvePolynomials(q) {
  // For simplicity, we try to evaluate a polynomial at x=1 or simplify terms
  // If input like: 2x^2 + 3x + 4
  addStep('Polynomial simplification or evaluation coming soon!', true);
  // Complex algebraic simplification needs a math parser, not easy in pure JS here.
}

// INEQUALITIES - basic solving linear inequality ax + b < 0
function solveInequalities(q) {
  // Try parsing something like "2x + 3 < 0"
  const m = q.match(/([+-]?\d*)x\s*([+-]\s*\d+)?\s*(<=|>=|<|>)\s*0/);
  if(!m) return addStep("‚ö†Ô∏è Please enter linear inequality in format: ax + b < 0", true);
  let a = m[1];
  let b = m[2];
  let op = m[3];
  if(a === '' || a === '+') a = 1;
  else if(a === '-') a = -1;
  else a = parseFloat(a);
  if(!b) b = 0;
  else b = parseFloat(b.replace(/\s+/g, ''));
  let boundary = -b/a;
  addStep(`Inequality: ${a}x ${op} ${-b}`, false);
  let solution;
  if(a > 0) {
    if(op === '<') solution = `x < ${boundary}`;
    else if(op === '<=') solution = `x ‚â§ ${boundary}`;
    else if(op === '>') solution = `x > ${boundary}`;
    else if(op === '>=') solution = `x ‚â• ${boundary}`;
  } else {
    if(op === '<') solution = `x > ${boundary}`;
    else if(op === '<=') solution = `x ‚â• ${boundary}`;
    else if(op === '>') solution = `x < ${boundary}`;
    else if(op === '>=') solution = `x ‚â§ ${boundary}`;
  }
  addStep(`Solution: ${solution}`, true);
}

// ALGEBRAIC EXPRESSIONS - simplify addition/subtraction of integers
function solveAlgebraicExpressions(q) {
  // Try evaluating simple expressions like "3 + 5 - 2"
  try {
    const res = eval(q);
    addStep(`Simplified result: ${res}`, true);
  } catch {
    addStep("‚ö†Ô∏è Could not simplify the expression.", true);
  }
}

// EXPONENTS - evaluate simple power expressions e.g. 2^3
function solveExponents(q) {
  // parse expressions like 2^3 or 5^2
  const m = q.match(/(\d+)\s*\^\s*(\d+)/);
  if(!m) return addStep("‚ö†Ô∏è Please enter expression like a^b", true);
  const base = parseFloat(m[1]);
  const exp = parseFloat(m[2]);
  const res = Math.pow(base, exp);
  addStep(`${base}^${exp} = ${res}`, true);
}

// RATIONAL NUMBERS - basic arithmetic for fractions a/b + c/d
function solveRationalNumbers(q) {
  // parse "a/b + c/d" format
  const m = q.match(/(\d+)\/(\d+)\s*([\+\-\*\/])\s*(\d+)\/(\d+)/);
  if(!m) return addStep("‚ö†Ô∏è Enter arithmetic with fractions like a/b + c/d", true);
  const a = parseInt(m[1]), b = parseInt(m[2]);
  const op = m[3];
  const c = parseInt(m[4]), d = parseInt(m[5]);
  let num, den;
  switch(op) {
    case '+': num = a*d + b*c; den = b*d; break;
    case '-': num = a*d - b*c; den = b*d; break;
    case '*': num = a*c; den = b*d; break;
    case '/': num = a*d; den = b*c; break;
  }
  addStep(`Result: ${num}/${den}`, true);
}

// SQUARES, CUBES & ROOTS
function solveSquaresCubesRoots(q) {
  // parse sqrt, cube root or squares like sqrt(9), cube root 27
  if(q.toLowerCase().includes('sqrt')) {
    const m = q.match(/sqrt\(?(\d+)\)?/i);
    if(!m) return addStep("‚ö†Ô∏è Enter sqrt(number) format", true);
    const n = parseFloat(m[1]);
    addStep(`‚àö${n} = ${Math.sqrt(n)}`, true);
  } else if(q.toLowerCase().includes('cube root')) {
    const m = q.match(/cube root\s*(\d+)/i);
    if(!m) return addStep("‚ö†Ô∏è Enter 'cube root number' format", true);
    const n = parseFloat(m[1]);
    addStep(`¬≥‚àö${n} = ${Math.cbrt(n)}`, true);
  } else {
    addStep("‚ö†Ô∏è Please enter sqrt or cube root expressions.", true);
  }
}

// INTEGERS - simple addition/subtraction
function solveIntegers(q) {
  try {
    const res = eval(q);
    addStep(`Result: ${res}`, true);
  } catch {
    addStep("‚ö†Ô∏è Could not evaluate integers expression.", true);
  }
}

// FRACTIONS - add or subtract fractions a/b + c/d
function solveFractions(q) {
  // Same as rational numbers for now
  solveRationalNumbers(q);
}

// DECIMALS - basic arithmetic
function solveDecimals(q) {
  try {
    const res = eval(q);
    addStep(`Result: ${res}`, true);
  } catch {
    addStep("‚ö†Ô∏è Could not evaluate decimal expression.", true);
  }
}

// PROBABILITY - simple P(E) = favorable / total
function solveProbability(q) {
  // parse "favorable=3 total=5"
  const fav = q.match(/favorable\s*=\s*(\d+)/i);
  const tot = q.match(/total\s*=\s*(\d+)/i);
  if(!fav || !tot) return addStep("‚ö†Ô∏è Provide favorable and total in format: favorable=number total=number", true);
  const favorable = parseInt(fav[1]);
  const total = parseInt(tot[1]);
  if(total === 0) return addStep("‚ö†Ô∏è Total cannot be zero.", true);
  const p = favorable / total;
  addStep(`Probability P(E) = favorable / total = ${favorable} / ${total} = ${p.toFixed(4)}`, true);
}

// PERCENTAGE - calculate percentage of a number
function solvePercentage(q) {
  // parse "x% of y"
  const m = q.match(/(\d+)%\s*of\s*(\d+)/i);
  if(!m) return addStep("‚ö†Ô∏è Enter format: x% of y", true);
  const per = parseFloat(m[1]);
  const num = parseFloat(m[2]);
  const res = (per/100)*num;
  addStep(`${per}% of ${num} = ${res}`, true);
}

// PERIMETER - calculate perimeter of shapes: square, rectangle, circle
function solvePerimeter(q) {
  if(q.toLowerCase().includes('square')) {
    const m = q.match(/side\s*=\s*(\d+)/i);
    if(!m) return addStep("‚ö†Ô∏è Provide side length like side=number", true);
    const s = parseFloat(m[1]);
    addStep(`Perimeter of square = 4 √ó side = 4 √ó ${s} = ${4*s}`, true);
  } else if(q.toLowerCase().includes('rectangle')) {
    const w = q.match(/width\s*=\s*(\d+)/i);
    const h = q.match(/height\s*=\s*(\d+)/i);
    if(!w || !h) return addStep("‚ö†Ô∏è Provide width and height like width=number height=number", true);
    const width = parseFloat(w[1]);
    const height = parseFloat(h[1]);
    addStep(`Perimeter of rectangle = 2 √ó (width + height) = 2 √ó (${width} + ${height}) = ${2*(width+height)}`, true);
  } else if(q.toLowerCase().includes('circle')) {
    const r = q.match(/radius\s*=\s*(\d+)/i);
    if(!r) return addStep("‚ö†Ô∏è Provide radius like radius=number", true);
    const radius = parseFloat(r[1]);
    addStep(`Perimeter (Circumference) of circle = 2œÄr = 2 √ó 3.1416 √ó ${radius} = ${(2*3.1416*radius).toFixed(2)}`, true);
  } else {
    addStep("‚ö†Ô∏è Please specify shape (square, rectangle, or circle) with dimensions.", true);
  }
}

// AREA - area of square, rectangle, circle
function solveArea(q) {
  if(q.toLowerCase().includes('square')) {
    const m = q.match(/side\s*=\s*(\d+)/i);
    if(!m) return addStep("‚ö†Ô∏è Provide side length like side=number", true);
    const s = parseFloat(m[1]);
    addStep(`Area of square = side¬≤ = ${s}¬≤ = ${s*s}`, true);
  } else if(q.toLowerCase().includes('rectangle')) {
    const w = q.match(/width\s*=\s*(\d+)/i);
    const h = q.match(/height\s*=\s*(\d+)/i);
    if(!w || !h) return addStep("‚ö†Ô∏è Provide width and height like width=number height=number", true);
    const width = parseFloat(w[1]);
    const height = parseFloat(h[1]);
    addStep(`Area of rectangle = width √ó height = ${width} √ó ${height} = ${width*height}`, true);
  } else if(q.toLowerCase().includes('circle')) {
    const r = q.match(/radius\s*=\s*(\d+)/i);
    if(!r) return addStep("‚ö†Ô∏è Provide radius like radius=number", true);
    const radius = parseFloat(r[1]);
    addStep(`Area of circle = œÄr¬≤ = 3.1416 √ó ${radius}¬≤ = ${(3.1416*radius*radius).toFixed(2)}`, true);
  } else {
    addStep("‚ö†Ô∏è Please specify shape (square, rectangle, or circle) with dimensions.", true);
  }
}

// VOLUME & SURFACE AREA
function solveVolumeSurface(q) {
  if(q.toLowerCase().includes('cube')) {
    const m = q.match(/side\s*=\s*(\d+)/i);
    if(!m) return addStep("‚ö†Ô∏è Provide side length like side=number", true);
    const s = parseFloat(m[1]);
    addStep(`Volume of cube = side¬≥ = ${s}¬≥ = ${Math.pow(s,3)}`, false);
    addStep(`Surface area of cube = 6 √ó side¬≤ = 6 √ó ${s}¬≤ = ${6 * s * s}`, true);
  } else if(q.toLowerCase().includes('cuboid')) {
    const l = q.match(/length\s*=\s*(\d+)/i);
    const w = q.match(/width\s*=\s*(\d+)/i);
    const h = q.match(/height\s*=\s*(\d+)/i);
    if(!l || !w || !h) return addStep("‚ö†Ô∏è Provide length, width, and height like length=number width=number height=number", true);
    const length = parseFloat(l[1]);
    const width = parseFloat(w[1]);
    const height = parseFloat(h[1]);
    addStep(`Volume of cuboid = length √ó width √ó height = ${length} √ó ${width} √ó ${height} = ${length*width*height}`, false);
    addStep(`Surface area of cuboid = 2(lw + lh + wh) = 2(${length}√ó${width} + ${length}√ó${height} + ${width}√ó${height}) = ${2*(length*width + length*height + width*height)}`, true);
  } else if(q.toLowerCase().includes('sphere')) {
    const r = q.match(/radius\s*=\s*(\d+)/i);
    if(!r) return addStep("‚ö†Ô∏è Provide radius like radius=number", true);
    const radius = parseFloat(r[1]);
    addStep(`Volume of sphere = (4/3)œÄr¬≥ = (4/3) √ó 3.1416 √ó ${radius}¬≥ = ${(4/3)*3.1416*Math.pow(radius,3).toFixed(2)}`, false);
    addStep(`Surface area of sphere = 4œÄr¬≤ = 4 √ó 3.1416 √ó ${radius}¬≤ = ${(4*3.1416*radius*radius).toFixed(2)}`, true);
  } else {
    addStep("‚ö†Ô∏è Please specify solid (cube, cuboid, or sphere) with dimensions.", true);
  }
}

// GEOMETRY Q&A - basic response
function solveGeometryQA(q) {
  addStep("Geometry Q&A feature coming soon!", true);
}

// GRAPHING - plot basic function y=mx+c
function solveGraphing(q) {
  const m = q.match(/y\s*=\s*([+-]?\d*)x\s*([+-]\s*\d+)?/i);
  if(!m) return addStep("‚ö†Ô∏è Enter function in form y=mx+c", true);
  let slope = m[1];
  let intercept = m[2] || "+0";
  if(slope === '' || slope === '+') slope = 1;
  else if(slope === '-') slope = -1;
  else slope = parseFloat(slope);
  intercept = parseFloat(intercept.replace(/\s+/g, ''));
  addStep(`Function: y = ${slope}x + ${intercept}`, false);
  addStep("Graph plotting coming soon!", true);
}

// MAIN solve function to direct queries to correct solver
function solveMathQuery(query) {
  clearSteps();
  query = query.trim();

  if(query.toLowerCase().startsWith('simple interest')) {
    solveSimpleInterest(query);
  } else if(query.toLowerCase().startsWith('compound interest')) {
    solveCompoundInterest(query);
  } else if(query.match(/[+-]?\d*x\s*[+-]\s*\d*\s*=\s*0/)) {
    solveLinearEquation(query);
  } else if(query.match(/[+-]?\d*x\^2\s*[+-]\s*\d*x\s*[+-]\s*\d*\s*=\s*0/)) {
    solveQuadraticEquation(query);
  } else if(query.toLowerCase().includes('polynomial')) {
    solvePolynomials(query);
  } else if(query.match(/[+-]?\d*x\s*[+-]\s*\d*\s*(<=|>=|<|>)\s*0/)) {
    solveInequalities(query);
  } else if(query.match(/^\d+(\s*[\+\-\*\/]\s*\d+)+$/)) {
    solveAlgebraicExpressions(query);
  } else if(query.match(/\d+\s*\^\s*\d+/)) {
    solveExponents(query);
  } else if(query.match(/\d+\/\d+\s*[\+\-\*\/]\s*\d+\/\d+/)) {
    solveRationalNumbers(query);
  } else if(query.toLowerCase().includes('sqrt') || query.toLowerCase().includes('cube root')) {
    solveSquaresCubesRoots(query);
  } else if(query.match(/^[\d\s\+\-\*\/\.]+$/)) {
    solveIntegers(query);
  } else if(query.match(/\d+\/\d+\s*[\+\-]\s*\d+\/\d+/)) {
    solveFractions(query);
  } else if(query.match(/[\d\.]+\s*[\+\-\*\/]\s*[\d\.]+/)) {
    solveDecimals(query);
  } else if(query.toLowerCase().startsWith('probability')) {
    solveProbability(query);
  } else if(query.toLowerCase().includes('% of')) {
    solvePercentage(query);
  } else if(query.toLowerCase().includes('perimeter')) {
    solvePerimeter(query);
  } else if(query.toLowerCase().includes('area')) {
    solveArea(query);
  } else if(query.toLowerCase().includes('volume') || query.toLowerCase().includes('surface area')) {
    solveVolumeSurface(query);
  } else if(query.toLowerCase().includes('graph')) {
    solveGraphing(query);
  } else {
    addStep("‚ö†Ô∏è Sorry, I couldn't recognize or solve that query.", true);
  }
}

// Example usage (uncomment below lines to test in environment):
// solveMathQuery("simple interest P=1000 R=5 T=2");
// solveMathQuery("compound interest P=1000 R=5 T=2 n=4");
// solveMathQuery("2x + 3 = 0");
// solveMathQuery("1x^2 - 3x + 2 = 0");
// solveMathQuery("2x + 3 < 0");
// solveMathQuery("3 + 5 - 2");
// solveMathQuery("2^3");
// solveMathQuery("1/2 + 3/4");
// solveMathQuery("sqrt(9)");
// solveMathQuery("cube root 27");
// solveMathQuery("50% of 200");
// solveMathQuery("perimeter square side=5");
// solveMathQuery("area rectangle width=4 height=7");
// solveMathQuery("volume cube side=3");

// Export the solveMathQuery function for external use (like integration)
export { solveMathQuery };Here‚Äôs a clean, modular JavaScript math solver framework that can parse and solve many types of math queries (simple interest, compound interest, linear & quadratic equations, inequalities, fractions, percentages, geometry, and more). It produces step-by-step explanations for each solution.

```js
// Helper function to output solution steps
function addStep(text, isFinal = false) {
  console.log(text + (isFinal ? " ‚úÖ" : ""));
}

// Clear steps (for UI or console)
function clearSteps() {
  console.clear();
}

// SIMPLE INTEREST: e.g. "simple interest P=1000 R=5 T=2"
function solveSimpleInterest(q) {
  const Pm = q.match(/P\s*=\s*([\d.]+)/i);
  const Rm = q.match(/R\s*=\s*([\d.]+)/i);
  const Tm = q.match(/T\s*=\s*([\d.]+)/i);
  if (!Pm || !Rm || !Tm) {
    return addStep("‚ö†Ô∏è Provide P, R, and T in format: P=number R=number T=number", true);
  }
  const P = parseFloat(Pm[1]);
  const R = parseFloat(Rm[1]);
  const T = parseFloat(Tm[1]);
  const SI = (P * R * T) / 100;
  addStep(`Simple Interest = (P √ó R √ó T) / 100 = (${P} √ó ${R} √ó ${T}) / 100 = ${SI}`, true);
}

// COMPOUND INTEREST: e.g. "compound interest P=1000 R=5 T=2 n=4"
function solveCompoundInterest(q) {
  const Pm = q.match(/P\s*=\s*([\d.]+)/i);
  const Rm = q.match(/R\s*=\s*([\d.]+)/i);
  const Tm = q.match(/T\s*=\s*([\d.]+)/i);
  const nm = q.match(/n\s*=\s*(\d+)/i);
  if (!Pm || !Rm || !Tm || !nm) {
    return addStep("‚ö†Ô∏è Provide P, R, T, and n in format: P=number R=number T=number n=number", true);
  }
  const P = parseFloat(Pm[1]);
  const R = parseFloat(Rm[1]);
  const T = parseFloat(Tm[1]);
  const n = parseInt(nm[1]);
  const A = P * Math.pow(1 + (R / 100) / n, n * T);
  const CI = A - P;
  addStep(`Compound Interest = A - P`, false);
  addStep(`A = P(1 + R/(100√ón))^(n√óT) = ${P} √ó (1 + ${R}/(100√ó${n}))^(${n}√ó${T}) = ${A.toFixed(2)}`, false);
  addStep(`Compound Interest = ${A.toFixed(2)} - ${P} = ${CI.toFixed(2)}`, true);
}

// LINEAR EQUATION ax + b = 0 e.g. "2x + 3 = 0"
function solveLinearEquation(q) {
  const m = q.match(/([+-]?\d*)x\s*([+-]\s*\d+)?\s*=\s*0/);
  if (!m) return addStep("‚ö†Ô∏è Enter linear equation in format: ax + b = 0", true);
  let a = m[1];
  let b = m[2];
  if (a === '' || a === '+') a = 1;
  else if (a === '-') a = -1;
  else a = parseFloat(a);
  b = b ? parseFloat(b.replace(/\s+/g, '')) : 0;
  const x = -b / a;
  addStep(`Solving ${a}x + ${b} = 0`, false);
  addStep(`x = -b / a = -(${b}) / ${a} = ${x}`, true);
}

// QUADRATIC EQUATION ax^2 + bx + c = 0 e.g. "1x^2 - 3x + 2 = 0"
function solveQuadraticEquation(q) {
  const m = q.match(/([+-]?\d*)x\^2\s*([+-]\s*\d*)x\s*([+-]\s*\d+)?\s*=\s*0/);
  if (!m) return addStep("‚ö†Ô∏è Enter quadratic equation in format: ax^2 + bx + c = 0", true);
  let a = m[1];
  let b = m[2];
  let c = m[3];
  if (a === '' || a === '+') a = 1;
  else if (a === '-') a = -1;
  else a = parseFloat(a);
  b = b ? parseFloat(b.replace(/\s+/g, '')) : 0;
  c = c ? parseFloat(c.replace(/\s+/g, '')) : 0;
  addStep(`Given quadratic equation: ${a}x¬≤ + ${b}x + ${c} = 0`, false);
  const D = b * b - 4 * a * c;
  addStep(`Discriminant D = b¬≤ - 4ac = (${b})¬≤ - 4 √ó ${a} √ó ${c} = ${D}`, false);
  if (D < 0) {
    addStep("No real roots.", true);
  } else if (D === 0) {
    const x = -b / (2 * a);
    addStep(`One real root x = -b/(2a) = -${b}/(2√ó${a}) = ${x}`, true);
  } else {
    const x1 = (-b + Math.sqrt(D)) / (2 * a);
    const x2 = (-b - Math.sqrt(D)) / (2 * a);
    addStep(`Two real roots:`, false);
    addStep(`x‚ÇÅ = (-b + ‚àöD) / 2a = (${ -b } + ‚àö${D}) / (2 √ó ${a}) = ${x1}`, false);
    addStep(`x‚ÇÇ = (-b - ‚àöD) / 2a = (${ -b } - ‚àö${D}) / (2 √ó ${a}) = ${x2}`, true);
  }
}

// ... similarly you can implement other functions like solveInequalities, solvePercentage, solveArea, solveVolumeSurface, etc.

// MAIN function to route query:
function solveMathQuery(query) {
  clearSteps();
  query = query.trim().toLowerCase();

  if (query.startsWith('simple interest')) {
    solveSimpleInterest(query);
  } else if (query.startsWith('compound interest')) {
    solveCompoundInterest(query);
  } else if (query.match(/[+-]?\d*x\s*[+-]\s*\d*\s*=\s*0/)) {
    solveLinearEquation(query);
  } else if (query.match(/[+-]?\d*x\^2\s*[+-]\s*\d*x\s*[+-]\s*\d*\s*=\s*0/)) {
    solveQuadraticEquation(query);
  } else {
    addStep("‚ö†Ô∏è Sorry, I couldn't recognize or solve that query.", true);
  }
}

// Usage examples:
solveMathQuery("simple interest P=1000 R=5 T=2");
solveMathQuery("compound interest P=1000 R=5 T=2 n=4");
solveMathQuery("2x + 3 = 0");
solveMathQuery("1x^2 - 3x + 2 = 0");
